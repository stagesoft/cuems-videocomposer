#include "OpenGLRenderer.h"
#include "../layer/VideoLayer.h"
#include "../osd/OSDRenderer.h"
#include "../utils/Logger.h"
#include "../input/HAPVideoInput.h"
#include "../input/InputSource.h"
#include "VideoShaders.h"
#include "HapShaders.h"
#include <GL/glew.h>  // Must be included before GL/gl.h
extern "C" {
#ifndef HAVE_GL
#define HAVE_GL
#endif
#include "../../homography.h"
}
#include <cstring>
#include <iomanip>
#include <sstream>
#include <cmath>

// HAP texture format constants
#ifndef GL_COMPRESSED_RGB_S3TC_DXT1_EXT
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
#endif
#ifndef GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
#endif
#ifndef GL_TEXTURE_2D
#define GL_TEXTURE_2D 0x0DE1
#endif

extern "C" {
#include <GL/gl.h>
}

#ifndef GL_BGRA
#define GL_BGRA 0x80E1
#endif
#ifndef GL_TEXTURE_RECTANGLE_ARB
#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
#endif

namespace videocomposer {

OpenGLRenderer::OpenGLRenderer()
    : textureId_(0)
    , textureWidth_(0)
    , textureHeight_(0)
    , viewportWidth_(0)
    , viewportHeight_(0)
    , letterbox_(true)
    , initialized_(false)
    , quadVAO_(0)
    , quadVBO_(0)
    , rgbaShader_(nullptr)
    , rgbaShaderHQ_(nullptr)
    , nv12Shader_(nullptr)
    , yuv420pShader_(nullptr)
    , useShaders_(false)
    , texturesToDelete_()
{
}

OpenGLRenderer::~OpenGLRenderer() {
    cleanup();
}

bool OpenGLRenderer::init() {
    if (initialized_) {
        return true;
    }
    
    // Initialize GLEW for modern OpenGL extension loading
    // Note: OpenGL context must already exist (created by DisplayBackend: X11Display or WaylandDisplay)
    // glewExperimental is needed for core profile and EGL contexts
    glewExperimental = GL_TRUE;
    GLenum glewErr = glewInit();
    // Clear any GL errors generated by glewInit (common with core profile)
    glGetError();
    
    if (glewErr != GLEW_OK && glewErr != GLEW_ERROR_NO_GLX_DISPLAY) {
        LOG_ERROR << "GLEW initialization failed: " << glewGetErrorString(glewErr);
        return false;
    }
    
    if (glewErr == GLEW_ERROR_NO_GLX_DISPLAY) {
        LOG_INFO << "GLEW: No GLX display (using EGL) - continuing with available extensions";
    }
    
    LOG_INFO << "OpenGL version: " << glGetString(GL_VERSION);
    LOG_INFO << "GLSL version: " << glGetString(GL_SHADING_LANGUAGE_VERSION);

    // Check for required OpenGL versions/extensions
    if (!GLEW_VERSION_3_3) {
        LOG_WARNING << "OpenGL 3.3 not available, some features may not work";
    }

    // Initialize OpenGL state (matches original xjadeo)
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  // Black background, fully opaque
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_TEXTURE_RECTANGLE_ARB);

    // Generate texture
    glGenTextures(1, &textureId_);
    if (textureId_ == 0) {
        return false;
    }
    
    // Initialize VBO/VAO for shader-based rendering
    if (!initQuadVBO()) {
        LOG_ERROR << "Failed to initialize quad VBO";
        return false;
    }
    
    // Initialize shaders (optional - gracefully fall back to fixed-function if fails)
    if (GLEW_VERSION_3_3) {
        if (initShaders()) {
            useShaders_ = true;
            LOG_INFO << "Shader-based rendering enabled";
        } else {
            LOG_WARNING << "Failed to initialize shaders, using fixed-function pipeline";
            useShaders_ = false;
        }
    } else {
        LOG_INFO << "OpenGL 3.3 not available, using fixed-function pipeline";
        useShaders_ = false;
    }

    initialized_ = true;
    return true;
}

void OpenGLRenderer::cleanup() {
    if (textureId_ != 0) {
        glDeleteTextures(1, &textureId_);
        textureId_ = 0;
    }
    
    // Cleanup all cached layer textures
    for (auto& pair : layerTextureCache_) {
        if (pair.second.textureId != 0) {
            glDeleteTextures(1, &pair.second.textureId);
        }
    }
    layerTextureCache_.clear();
    
    // Cleanup VBO/VAO
    cleanupQuadVBO();
    
    // Cleanup shaders
    cleanupShaders();
    
    initialized_ = false;
}

void OpenGLRenderer::setViewport(int x, int y, int width, int height) {
    viewportWidth_ = width;
    viewportHeight_ = height;
    glViewport(x, y, width, height);
    setupOrthoProjection();
}

void OpenGLRenderer::setupOrthoProjection() {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

bool OpenGLRenderer::uploadFrameToTexture(const FrameBuffer& frame) {
    if (!frame.isValid() || textureId_ == 0) {
        return false;
    }

    const FrameInfo& info = frame.info();

    // Update texture if size changed (matches original xjadeo)
    if (textureWidth_ != info.width || textureHeight_ != info.height) {
        textureWidth_ = info.width;
        textureHeight_ = info.height;

        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        // Use GL_REPLACE instead of GL_DECAL for proper texture rendering
        // GL_DECAL blends with vertex color based on alpha, which can cause black output
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

        // Allocate texture storage (BGRA format, matches original xjadeo)
        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA,
                     textureWidth_, textureHeight_, 0,
                     GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
    }

    // Upload frame data (matches original xjadeo: BGRA format)
    // Note: GL_TEXTURE_RECTANGLE_ARB doesn't need glEnable, just bind
    glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
    
    // Use BGRA format (matches original xjadeo)
    GLenum format = GL_BGRA;
    GLenum type = GL_UNSIGNED_BYTE;
    
    // Performance optimization: Use glTexSubImage2D when texture size hasn't changed
    // This is faster than glTexImage2D because it doesn't reallocate texture storage
    // Only use glTexImage2D when texture size changes (handled above)
    glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0,
                    0, 0,  // xoffset, yoffset
                    textureWidth_, textureHeight_,
                    format, type, frame.data());

    return true;
}

bool OpenGLRenderer::bindGPUTexture(const GPUTextureFrameBuffer& gpuFrame) {
    if (!gpuFrame.isValid()) {
        return false;
    }

    GLuint textureId = gpuFrame.getTextureId();
    if (textureId == 0) {
        return false;
    }

    // All GPU textures (HAP and hardware-decoded) use GL_TEXTURE_2D
    // GPUTextureFrameBuffer always allocates textures as GL_TEXTURE_2D
    GLenum target = GL_TEXTURE_2D;
    
    // CRITICAL: Disable GL_TEXTURE_RECTANGLE_ARB before enabling GL_TEXTURE_2D
    // Having both enabled simultaneously causes rendering issues
    glDisable(GL_TEXTURE_RECTANGLE_ARB);
    
    // CRITICAL: Ensure we're using texture unit 0 for shader-based rendering
    // Without this, the texture may be bound to the wrong unit
    glActiveTexture(GL_TEXTURE0);
    
    glEnable(target);
    glBindTexture(target, textureId);
    
    // Set texture parameters
    glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    // Set texture environment mode
    // GL_REPLACE: Use texture color directly (ignores vertex color, preserves texture alpha)
    // This is appropriate for video textures where we want the exact texture colors
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    
    // Update texture dimensions for rendering
    const FrameInfo& info = gpuFrame.info();
    textureWidth_ = info.width;
    textureHeight_ = info.height;
    
    return true;
}

void OpenGLRenderer::renderQuad(float x, float y, float width, float height) {
    // Use pixel coordinates for GL_TEXTURE_RECTANGLE_ARB (matches original xjadeo)
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, (GLfloat)textureHeight_); glVertex2f(x, y);
    glTexCoord2f((GLfloat)textureWidth_, (GLfloat)textureHeight_); glVertex2f(x + width, y);
    glTexCoord2f((GLfloat)textureWidth_, 0.0f); glVertex2f(x + width, y + height);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y + height);
    glEnd();
}

void OpenGLRenderer::renderQuadWithCrop(float x, float y, float width, float height,
                                       float texX, float texY, float texWidth, float texHeight) {
    // This function is used for both GL_TEXTURE_RECTANGLE_ARB (pixel coords) and GL_TEXTURE_2D (normalized coords)
    // For GL_TEXTURE_2D (HAP), texX/texY/texWidth/texHeight are already normalized (0.0-1.0)
    // For GL_TEXTURE_RECTANGLE_ARB, we need to convert to pixel coordinates
    // We'll detect which one based on whether the texture is bound as GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB
    // For now, assume normalized coordinates (GL_TEXTURE_2D) since this is called for HAP
    
    // Use normalized texture coordinates (0.0-1.0) for GL_TEXTURE_2D
    glBegin(GL_QUADS);
    glTexCoord2f(texX, texY + texHeight); glVertex2f(x, y);
    glTexCoord2f(texX + texWidth, texY + texHeight); glVertex2f(x + width, y);
    glTexCoord2f(texX + texWidth, texY); glVertex2f(x + width, y + height);
    glTexCoord2f(texX, texY); glVertex2f(x, y + height);
    glEnd();
}

void OpenGLRenderer::calculateCropCoordinates(const VideoLayer* layer, float& texX, float& texY, 
                                             float& texWidth, float& texHeight) {
    if (!layer) {
        return;
    }

    const auto& props = layer->properties();
    const FrameInfo& frameInfo = layer->getFrameInfo();
    
    calculateCropCoordinatesFromProps(props, frameInfo, texX, texY, texWidth, texHeight);
}

void OpenGLRenderer::calculateCropCoordinatesFromProps(const LayerProperties& props, const FrameInfo& frameInfo,
                                                       float& texX, float& texY, float& texWidth, float& texHeight) {
    if (frameInfo.width == 0 || frameInfo.height == 0) {
        texX = 0.0f;
        texY = 0.0f;
        texWidth = 1.0f;
        texHeight = 1.0f;
        return;
    }

    // Panorama mode: crop to 50% width with pan offset
    if (props.panoramaMode) {
        float cropWidth = frameInfo.width / 2.0f;
        float maxOffset = frameInfo.width - cropWidth;
        
        // Clamp pan offset
        int panOffset = props.panOffset;
        if (panOffset < 0) panOffset = 0;
        if (panOffset > static_cast<int>(maxOffset)) panOffset = static_cast<int>(maxOffset);
        
        // Calculate texture coordinates
        texX = static_cast<float>(panOffset) / frameInfo.width;
        texY = 0.0f;
        texWidth = cropWidth / frameInfo.width;
        texHeight = 1.0f;
    }
    // General crop
    else if (props.crop.enabled) {
        // Calculate crop rectangle in texture coordinates (0.0 to 1.0)
        texX = static_cast<float>(props.crop.x) / frameInfo.width;
        texY = static_cast<float>(props.crop.y) / frameInfo.height;
        texWidth = static_cast<float>(props.crop.width) / frameInfo.width;
        texHeight = static_cast<float>(props.crop.height) / frameInfo.height;
        
        // Clamp to valid range
        if (texX < 0.0f) texX = 0.0f;
        if (texY < 0.0f) texY = 0.0f;
        if (texX + texWidth > 1.0f) texWidth = 1.0f - texX;
        if (texY + texHeight > 1.0f) texHeight = 1.0f - texY;
    }
    else {
        // No crop - use full texture
        texX = 0.0f;
        texY = 0.0f;
        texWidth = 1.0f;
        texHeight = 1.0f;
    }
}

void OpenGLRenderer::applyLayerTransform(const VideoLayer* layer) {
    if (!layer) return;
    
    // Default quad size for backward compatibility
    applyLayerTransform(layer, 1.0f, 1.0f);
}

void OpenGLRenderer::applyLayerTransform(const VideoLayer* layer, float quad_x, float quad_y) {
    if (!layer) return;
    applyLayerTransformFromProps(layer->properties(), quad_x, quad_y);
}

void OpenGLRenderer::applyLayerTransformFromProps(const LayerProperties& props, float quad_x, float quad_y) {
    // Apply position (x, y) - convert from pixel coordinates to normalized coordinates
    // Viewport is -1 to 1, so we need to scale by viewport size
    if (viewportWidth_ > 0 && viewportHeight_ > 0) {
        float normX = (2.0f * props.x) / viewportWidth_;
        float normY = (2.0f * props.y) / viewportHeight_;
        glTranslatef(normX, -normY, 0.0f);  // Negative Y because OpenGL Y is inverted
    }
    
    // Apply scale
    glScalef(props.scaleX, props.scaleY, 1.0f);
    
    // Apply rotation (around center)
    if (props.rotation != 0.0f) {
        glTranslatef(0.5f, 0.5f, 0.0f);
        glRotatef(props.rotation, 0.0f, 0.0f, 1.0f);
        glTranslatef(-0.5f, -0.5f, 0.0f);
    }
    
    // Apply corner deformation (warping) if enabled
    if (props.cornerDeform.enabled) {
        // Calculate source corners (base quad)
        Point src[4];
        src[0].x = -quad_x;
        src[0].y = -quad_y;
        src[1].x = quad_x;
        src[1].y = -quad_y;
        src[2].x = quad_x;
        src[2].y = quad_y;
        src[3].x = -quad_x;
        src[3].y = quad_y;
        
        // Calculate destination corners (with deformation offsets)
        Point dst[4];
        dst[0].x = src[0].x + props.cornerDeform.corners[0];
        dst[0].y = src[0].y + props.cornerDeform.corners[1];
        dst[1].x = src[1].x + props.cornerDeform.corners[2];
        dst[1].y = src[1].y + props.cornerDeform.corners[3];
        dst[2].x = src[2].x + props.cornerDeform.corners[4];
        dst[2].y = src[2].y + props.cornerDeform.corners[5];
        dst[3].x = src[3].x + props.cornerDeform.corners[6];
        dst[3].y = src[3].y + props.cornerDeform.corners[7];
        
        // Calculate homography matrix
        GLfloat homography[16];
        findHomography(src, dst, homography);
        
        // Apply homography matrix
        glMultMatrixf(homography);
    }
}

void OpenGLRenderer::applyBlendMode(const VideoLayer* layer) {
    if (!layer) return;
    applyBlendModeFromProps(layer->properties());
}

void OpenGLRenderer::applyBlendModeFromProps(const LayerProperties& props) {
    switch (props.blendMode) {
        case LayerProperties::NORMAL:
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            break;
        case LayerProperties::MULTIPLY:
            glBlendFunc(GL_DST_COLOR, GL_ZERO);
            break;
        case LayerProperties::SCREEN:
            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_COLOR);
            break;
        case LayerProperties::OVERLAY:
            // Simplified overlay blend
            glBlendFunc(GL_SRC_ALPHA, GL_ONE);
            break;
    }
}

bool OpenGLRenderer::renderLayer(const VideoLayer* layer) {
    if (!layer || !layer->isReady()) {
        return false;
    }

    // Get properties reference (safe since everything runs in main thread)
    const LayerProperties& props = layer->properties();
    if (!props.visible) {
        return false;
    }

            // Check if frame is on GPU (hardware-decoded)
            const FrameBuffer* cpuBuffer = nullptr;
            const GPUTextureFrameBuffer* gpuBuffer = nullptr;
            bool isOnGPU = layer->getPreparedFrame(cpuBuffer, gpuBuffer);
            
            
            if (isOnGPU && gpuBuffer && gpuBuffer->isValid()) {
                // Frame is on GPU - use GPU rendering path
                const FrameInfo& frameInfo = layer->getFrameInfo();
                return renderLayerFromGPU(*gpuBuffer, props, frameInfo);
            } else if (!isOnGPU && cpuBuffer && cpuBuffer->isValid()) {
                // Frame is on CPU - use cached texture per layer
                // IMPORTANT: Each layer needs its own texture when using CPU frames
                // We cache textures per layer to avoid expensive create/delete every frame
                
                const FrameInfo& info = cpuBuffer->info();
                int layerId = layer->getLayerId();
                int layerTextureWidth = info.width;
                int layerTextureHeight = info.height;
                
                // Check if we have a cached texture for this layer
                GLuint layerTextureId = 0;
                auto cacheIt = layerTextureCache_.find(layerId);
                
                if (cacheIt != layerTextureCache_.end()) {
                    // Texture exists - check if size matches
                    if (cacheIt->second.width == layerTextureWidth && 
                        cacheIt->second.height == layerTextureHeight) {
                        // Reuse existing texture
                        layerTextureId = cacheIt->second.textureId;
                    } else {
                        // Size changed - delete old texture and create new one
                        texturesToDelete_.push_back(cacheIt->second.textureId);
                        layerTextureCache_.erase(cacheIt);
                        cacheIt = layerTextureCache_.end();
                    }
                }
                
                // Create new texture if needed
                if (layerTextureId == 0) {
                    glGenTextures(1, &layerTextureId);
                    if (layerTextureId == 0) {
                        return false;
                    }
                    
                    glBindTexture(GL_TEXTURE_RECTANGLE_ARB, layerTextureId);
                    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                    // Use GL_REPLACE instead of GL_DECAL for proper texture rendering
                    // GL_DECAL blends with vertex color based on alpha, which can cause black output
                    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
                    
                    // Allocate texture storage
                    glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, 
                                 layerTextureWidth, layerTextureHeight, 0,
                                 GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
                    
                    // Cache the texture
                    LayerTextureCache cache;
                    cache.textureId = layerTextureId;
                    cache.width = layerTextureWidth;
                    cache.height = layerTextureHeight;
                    layerTextureCache_[layerId] = cache;
                }
                
                // Upload frame data to cached texture
                glEnable(GL_TEXTURE_RECTANGLE_ARB);
                glBindTexture(GL_TEXTURE_RECTANGLE_ARB, layerTextureId);
                glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0,
                                layerTextureWidth, layerTextureHeight,
                                GL_BGRA, GL_UNSIGNED_BYTE, cpuBuffer->data());
                
                GLenum glErr = glGetError();
                if (glErr != GL_NO_ERROR) {
                    LOG_ERROR << "GL error after texture upload: 0x" << std::hex << glErr << std::dec;
                }

        // Calculate quad size with letterboxing (matches original xjadeo)
        // Original uses _gl_quad_x and _gl_quad_y for letterboxing
        float quad_x = 1.0f;
        float quad_y = 1.0f;
        
        // Get frame info for aspect ratio calculation
        const FrameInfo& frameInfo = layer->getFrameInfo();
        
        if (letterbox_) {
            // Calculate aspect ratios (matches original xjadeo logic)
            float asp_src = frameInfo.aspect > 0.0f ? frameInfo.aspect : (float)props.width / (float)props.height;
            float asp_dst = (float)viewportWidth_ / (float)viewportHeight_;
            
            if (asp_dst > asp_src) {
                // Destination is wider - letterbox left/right
                quad_x = asp_src / asp_dst;
                quad_y = 1.0f;
            } else {
                // Destination is taller - letterbox top/bottom
                quad_x = 1.0f;
                quad_y = asp_dst / asp_src;
            }
        }
        
        // Save matrix state before applying transforms
        glPushMatrix();
        
        // Apply layer transform using the thread-safe props copy
        applyLayerTransformFromProps(props, quad_x, quad_y);

        // Apply blend mode using the thread-safe props copy
        applyBlendModeFromProps(props);

        // Set opacity
        glColor4f(1.0f, 1.0f, 1.0f, props.opacity);
        
        // Render centered quad (matches original xjadeo)
        float x = -quad_x;
        float y = -quad_y;
        float w = 2.0f * quad_x;
        float h = 2.0f * quad_y;

                // Calculate texture coordinates for cropping/panorama using thread-safe props copy
                float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
                calculateCropCoordinatesFromProps(props, frameInfo, texX, texY, texWidth, texHeight);

                // Regular texture uses GL_TEXTURE_RECTANGLE_ARB (already bound above)
                // HAP is now treated as regular RGBA, not compressed
                // Use pixel coordinates for GL_TEXTURE_RECTANGLE_ARB
                // NOTE: renderQuad uses textureWidth_ and textureHeight_ members, so we need to pass them
                // Use a custom render here with explicit dimensions
                glBegin(GL_QUADS);
                glTexCoord2f(0.0f, (GLfloat)layerTextureHeight); glVertex2f(x, y);
                glTexCoord2f((GLfloat)layerTextureWidth, (GLfloat)layerTextureHeight); glVertex2f(x + w, y);
                glTexCoord2f((GLfloat)layerTextureWidth, 0.0f); glVertex2f(x + w, y + h);
                glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y + h);
                glEnd();
                
                GLenum quadErr = glGetError();
                if (quadErr != GL_NO_ERROR) {
                    LOG_ERROR << "GL error after quad render: 0x" << std::hex << quadErr << std::dec;
                }
                
                // Unbind texture (texture is cached, don't delete)
                glBindTexture(GL_TEXTURE_RECTANGLE_ARB, 0);
                glDisable(GL_TEXTURE_RECTANGLE_ARB);

                glPopMatrix();

                return true;
    } else {
        // No valid frame available
        return false;
    }
}

void OpenGLRenderer::compositeLayers(const std::vector<const VideoLayer*>& layers) {
    // Clear to opaque black (alpha = 1.0)
    glClear(GL_COLOR_BUFFER_BIT);

    // Render layers in z-order (already sorted by LayerManager)
    for (const VideoLayer* layer : layers) {
        if (layer && layer->isReady()) {
            bool rendered = renderLayer(layer);
            // If no frame was rendered, clear will show black screen (expected)
            // This is normal when waiting for MTC or when no frames are available yet
        }
    }
}

void OpenGLRenderer::updateTexture(int width, int height) {
    textureWidth_ = width;
    textureHeight_ = height;
    
    if (textureId_ != 0) {
        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, 
                     width, height, 0,
                     GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
    }
}

void OpenGLRenderer::cleanupDeferredTextures() {
    // Delete textures that were deferred from previous frame
    // This is called AFTER swapBuffers() to ensure OpenGL is done using them
    if (!texturesToDelete_.empty()) {
        glDeleteTextures(static_cast<GLsizei>(texturesToDelete_.size()), texturesToDelete_.data());
        texturesToDelete_.clear();
    }
}

bool OpenGLRenderer::renderLayerFromGPU(const GPUTextureFrameBuffer& gpuFrame, const LayerProperties& properties, const FrameInfo& frameInfo) {
    if (!gpuFrame.isValid()) {
        LOG_VERBOSE << "renderLayerFromGPU: gpuFrame is invalid";
        return false;
    }

    if (!properties.visible) {
        return false;
    }

    TexturePlaneType planeType = gpuFrame.getPlaneType();

    // For multi-plane formats (NV12, YUV420P), skip bindGPUTexture
    // We'll bind textures manually in the shader path
    if (planeType == TexturePlaneType::SINGLE) {
        // Single-plane (HAP, RGBA) - use bindGPUTexture
        if (!bindGPUTexture(gpuFrame)) {
            LOG_WARNING << "renderLayerFromGPU: bindGPUTexture failed";
            return false;
        }
    }

    // Calculate quad size with letterboxing first (needed for corner deformation)
    float quad_x = 1.0f;
    float quad_y = 1.0f;
    
    if (letterbox_) {
        float asp_src = frameInfo.aspect > 0.0f ? frameInfo.aspect : (float)properties.width / (float)properties.height;
        float asp_dst = (float)viewportWidth_ / (float)viewportHeight_;
        
        if (asp_dst > asp_src) {
            quad_x = asp_src / asp_dst;
            quad_y = 1.0f;
        } else {
            quad_x = 1.0f;
            quad_y = asp_dst / asp_src;
        }
    }
    
    // Use shader-based rendering if available (supports corner deformation)
    if (useShaders_ && rgbaShader_) {
        // Apply blend mode (use shared function to avoid duplication)
        applyBlendModeFromProps(properties);
        
        // Select shader based on texture format and quality setting
        ShaderProgram* shader = nullptr;
        
        if (planeType == TexturePlaneType::YUV_NV12 && nv12Shader_) {
            // NV12 format (VAAPI, CUDA)
            shader = nv12Shader_.get();
            
            GLuint texY = gpuFrame.getTextureId(0);
            GLuint texUV = gpuFrame.getTextureId(1);
            
            // Bind Y plane to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, texY);
            
            // Bind UV plane to texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, texUV);
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexY", 0);   // Texture unit 0
            shader->setUniform("uTexUV", 1);  // Texture unit 1
            
            
        } else if (planeType == TexturePlaneType::YUV_420P && yuv420pShader_) {
            // YUV420P format (software decoded, some hardware decoders)
            shader = yuv420pShader_.get();
            
            // Bind Y plane to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(0));
            
            // Bind U plane to texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(1));
            
            // Bind V plane to texture unit 2
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(2));
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexY", 0);   // Texture unit 0
            shader->setUniform("uTexU", 1);   // Texture unit 1
            shader->setUniform("uTexV", 2);   // Texture unit 2
            
        } else if (planeType == TexturePlaneType::HAP_Q_ALPHA && hapQAlphaShader_) {
            // HAP Q Alpha (dual texture: YCoCg color + alpha)
            shader = hapQAlphaShader_.get();
            
            // Bind YCoCg color texture to unit 0
            glActiveTexture(GL_TEXTURE0);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(0));
            
            // Bind alpha texture to unit 1
            glActiveTexture(GL_TEXTURE1);
            glEnable(GL_TEXTURE_2D);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(1));
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexture", 0);       // YCoCg texture unit 0
            shader->setUniform("uTextureAlpha", 1);  // Alpha texture unit 1
            
        } else {
            // RGBA/single-plane format (HAP, HAP Alpha, decompressed frames)
            // Check if this is HAP Q (YCoCg format)
            bool isHAP = gpuFrame.isHAPTexture();
            HapVariant variant = gpuFrame.getHapVariant();
            
            if (isHAP && variant == HapVariant::HAP_Q && hapQShader_) {
                // HAP Q: YCoCg DXT5 (single texture) - needs YCoCg→RGB conversion
                shader = hapQShader_.get();
                shader->use();
                shader->setUniform("uTexture", 0);  // Texture unit 0
            } else {
                // Standard RGBA/HAP/HAP Alpha/HAP R (BPTC RGBA renders like standard RGBA)
                // NOTE: HAP R support is UNTESTED - needs verification with actual HAP R files
                shader = (properties.cornerDeform.enabled && 
                         properties.cornerDeform.highQuality && 
                         rgbaShaderHQ_) 
                        ? rgbaShaderHQ_.get() 
                        : rgbaShader_.get();
                
                shader->use();
                shader->setUniform("uTexture", 0);  // Texture unit 0
            }
        }
        
        shader->setUniform("uOpacity", properties.opacity);
        
        // Handle corner deformation (homography warping) - works with all shader types
        if (properties.cornerDeform.enabled) {
            // Calculate source corners (base quad before warping)
            Point src[4];
            src[0].x = -quad_x;
            src[0].y = -quad_y;
            src[1].x = quad_x;
            src[1].y = -quad_y;
            src[2].x = quad_x;
            src[2].y = quad_y;
            src[3].x = -quad_x;
            src[3].y = quad_y;
            
            // Calculate destination corners (with deformation offsets)
            Point dst[4];
            dst[0].x = src[0].x + properties.cornerDeform.corners[0];
            dst[0].y = src[0].y + properties.cornerDeform.corners[1];
            dst[1].x = src[1].x + properties.cornerDeform.corners[2];
            dst[1].y = src[1].y + properties.cornerDeform.corners[3];
            dst[2].x = src[2].x + properties.cornerDeform.corners[4];
            dst[2].y = src[2].y + properties.cornerDeform.corners[5];
            dst[3].x = src[3].x + properties.cornerDeform.corners[6];
            dst[3].y = src[3].y + properties.cornerDeform.corners[7];
            
            // Compute homography matrix
            GLfloat homography[16];
            findHomography(src, dst, homography);
            
            shader->setUniform("uUseHomography", 1);
            shader->setUniformMatrix4fv("uHomography", homography);
            
            // Set anisotropy level for high-quality RGBA shader
            if (properties.cornerDeform.highQuality && 
                planeType == TexturePlaneType::SINGLE && 
                rgbaShaderHQ_ && shader == rgbaShaderHQ_.get()) {
                shader->setUniform("uAnisotropy", 4.0f);
            }
        } else {
            shader->setUniform("uUseHomography", 0);
        }
        
        // Compute MVP matrix (position, scale, rotation - homography applied separately in shader)
        float mvp[16];
        computeMVPMatrix(mvp, 0.0f, 0.0f, quad_x, quad_y, properties);
        shader->setUniformMatrix4fv("uMVP", mvp);
        
        // Calculate texture coordinates for cropping/panorama
        float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
        calculateCropCoordinatesFromProps(properties, frameInfo, texX, texY, texWidth, texHeight);
        
        // TODO: Implement texture coordinate transformation for crop/panorama in shader
        // For now, we'll render without crop (will be implemented in Phase 2)
        
        // Bind VAO and draw
        glBindVertexArray(quadVAO_);
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
        glBindVertexArray(0);
        
        // CRITICAL: Force GPU to finish drawing before we unbind
        // This ensures DMA-BUF data has been fully sampled
        if (planeType == TexturePlaneType::YUV_NV12) {
            glFinish();
        }
        
        shader->unbind();
        
        // Unbind and disable multi-plane textures (like mpv does)
        if (planeType == TexturePlaneType::YUV_NV12 || planeType == TexturePlaneType::YUV_420P) {
            // Unbind texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, 0);
            glDisable(GL_TEXTURE_2D);
            
            // Unbind texture unit 0
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, 0);
            glDisable(GL_TEXTURE_2D);
            
            if (planeType == TexturePlaneType::YUV_420P) {
                // Also unbind texture unit 2 for YUV420P
                glActiveTexture(GL_TEXTURE2);
                glBindTexture(GL_TEXTURE_2D, 0);
                glDisable(GL_TEXTURE_2D);
                glActiveTexture(GL_TEXTURE0);
            }
        }
        
        return true;
    }

    // Fallback: Fixed-function pipeline (only if shaders unavailable)
    // Apply layer transform
    glPushMatrix();
    
    // Apply position (x, y) - convert from pixel coordinates to normalized coordinates
    if (viewportWidth_ > 0 && viewportHeight_ > 0) {
        float normX = (2.0f * properties.x) / viewportWidth_;
        float normY = (2.0f * properties.y) / viewportHeight_;
        glTranslatef(normX, -normY, 0.0f);  // Negative Y because OpenGL Y is inverted
    }
    
    glScalef(properties.scaleX, properties.scaleY, 1.0f);
    
    // Apply rotation (around center)
    if (properties.rotation != 0.0f) {
        glTranslatef(0.5f, 0.5f, 0.0f);
        glRotatef(properties.rotation, 0.0f, 0.0f, 1.0f);
        glTranslatef(-0.5f, -0.5f, 0.0f);
    }
    
    // Apply corner deformation (warping) if enabled
    if (properties.cornerDeform.enabled) {
        // Calculate source corners (base quad)
        Point src[4];
        src[0].x = -quad_x;
        src[0].y = -quad_y;
        src[1].x = quad_x;
        src[1].y = -quad_y;
        src[2].x = quad_x;
        src[2].y = quad_y;
        src[3].x = -quad_x;
        src[3].y = quad_y;
        
        // Calculate destination corners (with deformation offsets)
        Point dst[4];
        dst[0].x = src[0].x + properties.cornerDeform.corners[0];
        dst[0].y = src[0].y + properties.cornerDeform.corners[1];
        dst[1].x = src[1].x + properties.cornerDeform.corners[2];
        dst[1].y = src[1].y + properties.cornerDeform.corners[3];
        dst[2].x = src[2].x + properties.cornerDeform.corners[4];
        dst[2].y = src[2].y + properties.cornerDeform.corners[5];
        dst[3].x = src[3].x + properties.cornerDeform.corners[6];
        dst[3].y = src[3].y + properties.cornerDeform.corners[7];
        
        // Calculate homography matrix
        GLfloat homography[16];
        findHomography(src, dst, homography);
        
        // Apply homography matrix
        glMultMatrixf(homography);
    }

    // Apply blend mode (use shared function to avoid duplication)
    applyBlendModeFromProps(properties);

    // Set opacity
    glColor4f(1.0f, 1.0f, 1.0f, properties.opacity);
    
    // Render centered quad
    float x = -quad_x;
    float y = -quad_y;
    float w = 2.0f * quad_x;
    float h = 2.0f * quad_y;

    // Calculate texture coordinates for cropping/panorama
    float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
    calculateCropCoordinatesFromProps(properties, frameInfo, texX, texY, texWidth, texHeight);

    // Render quad with texture coordinates
    // All GPU textures (HAP and hardware-decoded) use GL_TEXTURE_2D
    // GL_TEXTURE_2D uses normalized texture coordinates (0.0-1.0)
    GLenum target = GL_TEXTURE_2D;
    
    // Use normalized texture coordinates (0.0-1.0) for GL_TEXTURE_2D
    glBegin(GL_QUADS);
    glTexCoord2f(texX, texY + texHeight); glVertex2f(x, y);
    glTexCoord2f(texX + texWidth, texY + texHeight); glVertex2f(x + w, y);
    glTexCoord2f(texX + texWidth, texY); glVertex2f(x + w, y + h);
    glTexCoord2f(texX, texY); glVertex2f(x, y + h);
    glEnd();

    // Disable texture
    glDisable(target);
    glPopMatrix();

    return true;
}

void OpenGLRenderer::renderOSDItems(const std::vector<OSDRenderItem>& items) {
    if (items.empty()) {
        return;
    }

    // Save current OpenGL state before modifying for OSD rendering
    glPushAttrib(GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT | GL_TEXTURE_BIT);
    
    // CRITICAL: Disable GL_TEXTURE_RECTANGLE_ARB (used by video layers) before rendering OSD
    // OSD uses GL_TEXTURE_2D, and both cannot be active simultaneously
    glDisable(GL_TEXTURE_RECTANGLE_ARB);
    
    // Save and set projection matrix for OSD (2D overlay in normalized coordinates)
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    glOrtho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);

    // Save and set modelview matrix for OSD
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    // Disable depth test (we're rendering 2D overlay on top of everything)
    glDisable(GL_DEPTH_TEST);
    // Ensure OSD is rendered on top by using a high depth value if depth test were enabled
    // Since depth test is disabled, this is just for clarity

    // Enable blending for OSD
    glEnable(GL_BLEND);
    // Use standard alpha blending for correct rendering of textures with alpha
    // GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA works for non-premultiplied alpha
    // This ensures transparent pixels (A=0) are completely invisible
    // When A=0: src contribution = 0, dst contribution = 1.0 * dst (unchanged)
    // When A=255: src contribution = 1.0 * src, dst contribution = 0 (fully opaque)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // Disable face culling
    glDisable(GL_CULL_FACE);
    
    // Enable texture 2D (OSD uses GL_TEXTURE_2D, not GL_TEXTURE_RECTANGLE_ARB)
    glEnable(GL_TEXTURE_2D);
    
    // Set color to white (texture provides color)
    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

    // Render each OSD item
    for (const auto& item : items) {
        if (item.textureId == 0) {
            LOG_WARNING << "OSD: Skipping item with textureId=0";
            continue;
        }

        glBindTexture(GL_TEXTURE_2D, item.textureId);
        
        // Set texture environment to MODULATE for proper alpha blending
        // Video layers use GL_DECAL which ignores alpha - we need MODULATE for transparency
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        // Calculate normalized coordinates
        // OpenGL coordinates: -1 to 1, with origin at center, Y up (top=1.0, bottom=-1.0)
        // Screen coordinates: 0 to viewportWidth/Height, with origin at top-left, Y down (top=0, bottom=height)
        // item.x and item.y are in screen pixels from top-left (item.y is top of text)
        float x = -1.0f + (2.0f * item.x / viewportWidth_);
        // Convert screen Y (top=0) to OpenGL Y (top=1.0): y_gl = 1.0 - 2.0 * (y_screen / height)
        float y = 1.0f - (2.0f * item.y / viewportHeight_);
        float w = 2.0f * item.width / viewportWidth_;
        // Height is negative because we're going down from top
        float h = -2.0f * item.height / viewportHeight_;

        // Ensure texture is bound and enabled
        glEnable(GL_TEXTURE_2D);
        
        // Set color to white with full opacity for text
        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

        // Render textured quad with proper texture coordinates
        // OpenGL texture coordinates: (0,0) = bottom-left, (1,1) = top-right
        // Our bitmap is stored with (0,0) at top-left, so we need to flip Y
        // Top-left vertex -> (0,0) texture (bitmap top-left), bottom-left -> (0,1) texture (bitmap bottom-left)
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y);           // Top-left vertex -> bitmap top-left (0,0)
        glTexCoord2f(1.0f, 0.0f); glVertex2f(x + w, y);       // Top-right vertex -> bitmap top-right (1,0)
        glTexCoord2f(1.0f, 1.0f); glVertex2f(x + w, y + h);   // Bottom-right vertex -> bitmap bottom-right (1,1)
        glTexCoord2f(0.0f, 1.0f); glVertex2f(x, y + h);       // Bottom-left vertex -> bitmap bottom-left (0,1)
        glEnd();
    }

    glBindTexture(GL_TEXTURE_2D, 0);
    glDisable(GL_TEXTURE_2D);
    
    // Restore matrices (must restore in reverse order)
    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    
    // Restore all OpenGL state (including GL_TEXTURE_RECTANGLE_ARB if it was enabled)
    glPopAttrib();
    
    // Re-enable GL_TEXTURE_RECTANGLE_ARB for video layers (they need it for next frame)
    glEnable(GL_TEXTURE_RECTANGLE_ARB);
}

bool OpenGLRenderer::initQuadVBO() {
    // Create a unit quad for rendering
    // Positions: [-1, -1] to [1, 1] (will be transformed by MVP matrix)
    // TexCoords: [0, 0] to [1, 1] (normalized texture coordinates)
    struct Vertex {
        float x, y;        // Position
        float u, v;        // Texture coordinate
    };
    
    // Quad vertices (two triangles forming a quad)
    // Order: bottom-left, bottom-right, top-right, top-left
    Vertex vertices[] = {
        {-1.0f, -1.0f,  0.0f, 1.0f},  // Bottom-left
        { 1.0f, -1.0f,  1.0f, 1.0f},  // Bottom-right
        { 1.0f,  1.0f,  1.0f, 0.0f},  // Top-right
        {-1.0f,  1.0f,  0.0f, 0.0f}   // Top-left
    };
    
    // Generate VAO and VBO
    glGenVertexArrays(1, &quadVAO_);
    glGenBuffers(1, &quadVBO_);
    
    if (quadVAO_ == 0 || quadVBO_ == 0) {
        LOG_ERROR << "Failed to generate VAO/VBO";
        cleanupQuadVBO();
        return false;
    }
    
    // Bind VAO
    glBindVertexArray(quadVAO_);
    
    // Bind and fill VBO
    glBindBuffer(GL_ARRAY_BUFFER, quadVBO_);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    // Set up vertex attributes
    // Position attribute (location = 0)
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
    
    // TexCoord attribute (location = 1)
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(2 * sizeof(float)));
    
    // Unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
    
    LOG_VERBOSE << "Quad VBO/VAO initialized (VAO: " << quadVAO_ << ", VBO: " << quadVBO_ << ")";
    return true;
}

void OpenGLRenderer::cleanupQuadVBO() {
    if (quadVBO_ != 0) {
        glDeleteBuffers(1, &quadVBO_);
        quadVBO_ = 0;
    }
    if (quadVAO_ != 0) {
        glDeleteVertexArrays(1, &quadVAO_);
        quadVAO_ = 0;
    }
}

bool OpenGLRenderer::initShaders() {
    // Create RGBA shader (for CPU frames, HAP)
    rgbaShader_ = std::make_unique<ShaderProgram>();
    if (!rgbaShader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_RGBA)) {
        LOG_ERROR << "Failed to create RGBA shader";
        cleanupShaders();
        return false;
    }
    
    // Create high-quality RGBA shader (for extreme corner warping)
    rgbaShaderHQ_ = std::make_unique<ShaderProgram>();
    if (!rgbaShaderHQ_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_RGBA_HQ)) {
        LOG_WARNING << "Failed to create HQ RGBA shader, will use standard quality for warping";
        rgbaShaderHQ_.reset();
    }
    
    // Create NV12 shader (for VAAPI/CUDA)
    nv12Shader_ = std::make_unique<ShaderProgram>();
    if (!nv12Shader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_NV12)) {
        LOG_ERROR << "Failed to create NV12 shader";
        cleanupShaders();
        return false;
    }
    
    // Create YUV420P shader (fallback)
    yuv420pShader_ = std::make_unique<ShaderProgram>();
    if (!yuv420pShader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_YUV420P)) {
        LOG_ERROR << "Failed to create YUV420P shader";
        cleanupShaders();
        return false;
    }
    
    // Create HAP Q shader (YCoCg→RGB conversion)
    hapQShader_ = std::make_unique<ShaderProgram>();
    if (!hapQShader_->createFromSource(HAP_VERTEX_SHADER, HAP_Q_FRAGMENT_SHADER)) {
        LOG_WARNING << "Failed to create HAP Q shader, HAP Q videos will use fallback";
        hapQShader_.reset();
    }
    
    // Create HAP Q Alpha shader (dual texture: YCoCg + alpha)
    hapQAlphaShader_ = std::make_unique<ShaderProgram>();
    if (!hapQAlphaShader_->createFromSource(HAP_VERTEX_SHADER, HAP_Q_ALPHA_FRAGMENT_SHADER)) {
        LOG_WARNING << "Failed to create HAP Q Alpha shader, HAP Q Alpha videos will use fallback";
        hapQAlphaShader_.reset();
    }
    
    LOG_VERBOSE << "All video shaders compiled successfully";
    return true;
}

void OpenGLRenderer::cleanupShaders() {
    rgbaShader_.reset();
    rgbaShaderHQ_.reset();
    nv12Shader_.reset();
    yuv420pShader_.reset();
    hapQShader_.reset();
    hapQAlphaShader_.reset();
}

void OpenGLRenderer::computeMVPMatrix(float* mvp, float x, float y, float width, float height,
                                     const LayerProperties& props) {
    // Initialize as identity matrix
    for (int i = 0; i < 16; i++) {
        mvp[i] = 0.0f;
    }
    mvp[0] = mvp[5] = mvp[10] = mvp[15] = 1.0f;
    
    // Apply position and scale (model matrix)
    // Normalized device coordinates: x, y in [-1, 1]
    float scaleX = width * props.scaleX;
    float scaleY = height * props.scaleY;
    
    // Position: center the quad at (x, y)
    float posX = x;
    float posY = y;
    
    // Build MVP as: Translation * Rotation * Scale
    // For simplicity, we'll build a combined matrix
    
    // Scale
    mvp[0] = scaleX;   // Scale X
    mvp[5] = scaleY;   // Scale Y
    
    // Rotation (around Z axis)
    if (props.rotation != 0.0f) {
        float rad = props.rotation * M_PI / 180.0f;
        float cosR = std::cos(rad);
        float sinR = std::sin(rad);
        
        // Combine scale and rotation
        float m00 = scaleX * cosR;
        float m01 = scaleX * (-sinR);
        float m10 = scaleY * sinR;
        float m11 = scaleY * cosR;
        
        mvp[0] = m00;
        mvp[1] = m10;
        mvp[4] = m01;
        mvp[5] = m11;
    }
    
    // Translation
    mvp[12] = posX;
    mvp[13] = posY;
}

void OpenGLRenderer::renderQuadWithShader(ShaderProgram* shader, float x, float y, 
                                         float width, float height, const LayerProperties& props) {
    if (!shader || !shader->isValid()) {
        return;
    }
    
    // Use shader
    shader->use();
    
    // Compute MVP matrix
    float mvp[16];
    computeMVPMatrix(mvp, x, y, width, height, props);
    
    // Set uniforms
    shader->setUniformMatrix4fv("uMVP", mvp);
    shader->setUniform("uOpacity", props.opacity);
    
    // Bind VAO and draw
    glBindVertexArray(quadVAO_);
    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
    glBindVertexArray(0);
    
    // Unbind shader
    shader->unbind();
}

} // namespace videocomposer

