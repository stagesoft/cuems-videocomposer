#include "OpenGLRenderer.h"
#include "../layer/VideoLayer.h"
#include "../osd/OSDRenderer.h"
#include "../utils/Logger.h"
#include "../input/HAPVideoInput.h"
#include "../input/InputSource.h"
#include "VideoShaders.h"
#include "HapShaders.h"
#include <GL/glew.h>  // Must be included before GL/gl.h
extern "C" {
#ifndef HAVE_GL
#define HAVE_GL
#endif
#include "../../homography.h"
}
#include <cstring>
#include <iomanip>
#include <sstream>
#include <cmath>

// HAP texture format constants
#ifndef GL_COMPRESSED_RGB_S3TC_DXT1_EXT
#define GL_COMPRESSED_RGB_S3TC_DXT1_EXT 0x83F0
#endif
#ifndef GL_COMPRESSED_RGBA_S3TC_DXT5_EXT
#define GL_COMPRESSED_RGBA_S3TC_DXT5_EXT 0x83F3
#endif
#ifndef GL_TEXTURE_2D
#define GL_TEXTURE_2D 0x0DE1
#endif

extern "C" {
#include <GL/gl.h>
}

#ifndef GL_BGRA
#define GL_BGRA 0x80E1
#endif
#ifndef GL_TEXTURE_RECTANGLE_ARB
#define GL_TEXTURE_RECTANGLE_ARB 0x84F5
#endif

namespace videocomposer {

OpenGLRenderer::OpenGLRenderer()
    : textureId_(0)
    , textureWidth_(0)
    , textureHeight_(0)
    , viewportWidth_(0)
    , viewportHeight_(0)
    , letterbox_(true)
    , initialized_(false)
    , quadVAO_(0)
    , quadVBO_(0)
    , rgbaShader_(nullptr)
    , rgbaShaderHQ_(nullptr)
    , nv12Shader_(nullptr)
    , yuv420pShader_(nullptr)
    , useShaders_(false)
    , texturesToDelete_()
    , masterFBO_(0)
    , masterFBOTexture_(0)
    , masterFBOWidth_(0)
    , masterFBOHeight_(0)
    , masterFBOInitialized_(false)
{
}

OpenGLRenderer::~OpenGLRenderer() {
    cleanup();
}

bool OpenGLRenderer::init() {
    if (initialized_) {
        return true;
    }
    
    // Initialize GLEW for modern OpenGL extension loading
    // Note: OpenGL context must already exist (created by DisplayBackend: X11Display or WaylandDisplay)
    // glewExperimental is needed for core profile and EGL contexts
    glewExperimental = GL_TRUE;
    GLenum glewErr = glewInit();
    // Clear any GL errors generated by glewInit (common with core profile)
    glGetError();
    
    if (glewErr != GLEW_OK && glewErr != GLEW_ERROR_NO_GLX_DISPLAY) {
        LOG_ERROR << "GLEW initialization failed: " << glewGetErrorString(glewErr);
        return false;
    }
    
    if (glewErr == GLEW_ERROR_NO_GLX_DISPLAY) {
        LOG_INFO << "GLEW: No GLX display (using EGL) - continuing with available extensions";
    }
    
    LOG_INFO << "OpenGL version: " << glGetString(GL_VERSION);
    LOG_INFO << "GLSL version: " << glGetString(GL_SHADING_LANGUAGE_VERSION);

    // Check for required OpenGL versions/extensions
    if (!GLEW_VERSION_3_3) {
        LOG_WARNING << "OpenGL 3.3 not available, some features may not work";
    }

    // Check if we're in core profile (DRM/EGL uses core profile)
    // mpv always uses Core Profile and never calls glEnable(GL_TEXTURE_*)
    GLint profileMask = 0;
    glGetIntegerv(GL_CONTEXT_PROFILE_MASK, &profileMask);
    isCoreProfile_ = (profileMask & GL_CONTEXT_CORE_PROFILE_BIT) != 0;
    
    if (isCoreProfile_) {
        LOG_INFO << "OpenGLRenderer: Running in Core Profile mode (like mpv)";
    }
    
    // Initialize OpenGL state (matches original xjadeo)
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);  // Black background, fully opaque
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // glEnable(GL_TEXTURE_*) is deprecated in Core Profile - skip it (mpv doesn't use it)
    if (!isCoreProfile_) {
    glEnable(GL_TEXTURE_RECTANGLE_ARB);
    }

    // Generate texture
    glGenTextures(1, &textureId_);
    if (textureId_ == 0) {
        return false;
    }
    
    // Initialize VBO/VAO for shader-based rendering
    if (!initQuadVBO()) {
        LOG_ERROR << "Failed to initialize quad VBO";
        return false;
    }
    
    // Initialize shaders (optional - gracefully fall back to fixed-function if fails)
    if (GLEW_VERSION_3_3) {
        if (initShaders()) {
            useShaders_ = true;
            LOG_INFO << "Shader-based rendering enabled";
        } else {
            LOG_WARNING << "Failed to initialize shaders, using fixed-function pipeline";
            useShaders_ = false;
        }
    } else {
        LOG_INFO << "OpenGL 3.3 not available, using fixed-function pipeline";
        useShaders_ = false;
    }

    initialized_ = true;
    return true;
}

void OpenGLRenderer::cleanup() {
    if (textureId_ != 0) {
        glDeleteTextures(1, &textureId_);
        textureId_ = 0;
    }
    
    // Cleanup all cached layer textures and PBOs
    for (auto& pair : layerTextureCache_) {
        if (pair.second.textureId != 0) {
            glDeleteTextures(1, &pair.second.textureId);
        }
        cleanupLayerPBOs(pair.second);
    }
    layerTextureCache_.clear();
    
    // Cleanup VBO/VAO
    cleanupQuadVBO();
    
    // Cleanup shaders
    cleanupShaders();
    
    // Cleanup master FBO
    cleanupMasterFBO();
    
    initialized_ = false;
}

// PBO helper methods for async texture upload
bool OpenGLRenderer::initLayerPBOs(LayerTextureCache& cache, int width, int height) {
    if (cache.pboInitialized) {
        return true;
    }
    
    // Calculate buffer size (BGRA = 4 bytes per pixel)
    size_t bufferSize = static_cast<size_t>(width) * height * 4;
    
    glGenBuffers(2, cache.pbo);
    if (cache.pbo[0] == 0 || cache.pbo[1] == 0) {
        LOG_ERROR << "Failed to create PBOs for layer texture upload";
        return false;
    }
    
    // Initialize both PBOs with empty storage
    for (int i = 0; i < 2; i++) {
        glBindBuffer(GL_PIXEL_UNPACK_BUFFER, cache.pbo[i]);
        glBufferData(GL_PIXEL_UNPACK_BUFFER, bufferSize, nullptr, GL_STREAM_DRAW);
    }
    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
    
    cache.pboIndex = 0;
    cache.pboInitialized = true;
    
    LOG_DEBUG << "Initialized PBO double-buffering for layer (" << width << "x" << height << ")";
    return true;
}

void OpenGLRenderer::cleanupLayerPBOs(LayerTextureCache& cache) {
    if (cache.pboInitialized) {
        glDeleteBuffers(2, cache.pbo);
        cache.pbo[0] = 0;
        cache.pbo[1] = 0;
        cache.pboInitialized = false;
    }
}

void OpenGLRenderer::setViewport(int x, int y, int width, int height) {
    viewportWidth_ = width;
    viewportHeight_ = height;
    glViewport(x, y, width, height);
    setupOrthoProjection();
}

void OpenGLRenderer::setupOrthoProjection() {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

bool OpenGLRenderer::uploadFrameToTexture(const FrameBuffer& frame) {
    if (!frame.isValid() || textureId_ == 0) {
        return false;
    }

    const FrameInfo& info = frame.info();

    // Update texture if size changed (matches original xjadeo)
    if (textureWidth_ != info.width || textureHeight_ != info.height) {
        textureWidth_ = info.width;
        textureHeight_ = info.height;

        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        // Use GL_REPLACE instead of GL_DECAL for proper texture rendering
        // GL_DECAL blends with vertex color based on alpha, which can cause black output
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

        // Allocate texture storage (BGRA format, matches original xjadeo)
        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA,
                     textureWidth_, textureHeight_, 0,
                     GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
    }

    // Upload frame data (matches original xjadeo: BGRA format)
    // Note: GL_TEXTURE_RECTANGLE_ARB doesn't need glEnable, just bind
    glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
    
    // Use BGRA format (matches original xjadeo)
    GLenum format = GL_BGRA;
    GLenum type = GL_UNSIGNED_BYTE;
    
    // Performance optimization: Use glTexSubImage2D when texture size hasn't changed
    // This is faster than glTexImage2D because it doesn't reallocate texture storage
    // Only use glTexImage2D when texture size changes (handled above)
    glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0,
                    0, 0,  // xoffset, yoffset
                    textureWidth_, textureHeight_,
                    format, type, frame.data());

    return true;
}

bool OpenGLRenderer::bindGPUTexture(const GPUTextureFrameBuffer& gpuFrame) {
    if (!gpuFrame.isValid()) {
        return false;
    }

    GLuint textureId = gpuFrame.getTextureId();
    if (textureId == 0) {
        return false;
    }

    // All GPU textures (HAP and hardware-decoded) use GL_TEXTURE_2D
    // GPUTextureFrameBuffer always allocates textures as GL_TEXTURE_2D
    GLenum target = GL_TEXTURE_2D;
    
    // CRITICAL: Disable GL_TEXTURE_RECTANGLE_ARB before enabling GL_TEXTURE_2D
    // Having both enabled simultaneously causes rendering issues
    glDisable(GL_TEXTURE_RECTANGLE_ARB);
    
    // CRITICAL: Ensure we're using texture unit 0 for shader-based rendering
    // Without this, the texture may be bound to the wrong unit
    glActiveTexture(GL_TEXTURE0);
    
    glEnable(target);
    glBindTexture(target, textureId);
    
    // Set texture parameters
    glTexParameteri(target, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(target, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    // Set texture environment mode
    // GL_REPLACE: Use texture color directly (ignores vertex color, preserves texture alpha)
    // This is appropriate for video textures where we want the exact texture colors
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    
    // Update texture dimensions for rendering
    const FrameInfo& info = gpuFrame.info();
    textureWidth_ = info.width;
    textureHeight_ = info.height;
    
    return true;
}

void OpenGLRenderer::renderQuad(float x, float y, float width, float height) {
    // Use pixel coordinates for GL_TEXTURE_RECTANGLE_ARB (matches original xjadeo)
    glBegin(GL_QUADS);
    glTexCoord2f(0.0f, (GLfloat)textureHeight_); glVertex2f(x, y);
    glTexCoord2f((GLfloat)textureWidth_, (GLfloat)textureHeight_); glVertex2f(x + width, y);
    glTexCoord2f((GLfloat)textureWidth_, 0.0f); glVertex2f(x + width, y + height);
    glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y + height);
    glEnd();
}

void OpenGLRenderer::renderQuadWithCrop(float x, float y, float width, float height,
                                       float texX, float texY, float texWidth, float texHeight) {
    // This function is used for both GL_TEXTURE_RECTANGLE_ARB (pixel coords) and GL_TEXTURE_2D (normalized coords)
    // For GL_TEXTURE_2D (HAP), texX/texY/texWidth/texHeight are already normalized (0.0-1.0)
    // For GL_TEXTURE_RECTANGLE_ARB, we need to convert to pixel coordinates
    // We'll detect which one based on whether the texture is bound as GL_TEXTURE_2D or GL_TEXTURE_RECTANGLE_ARB
    // For now, assume normalized coordinates (GL_TEXTURE_2D) since this is called for HAP
    
    // Use normalized texture coordinates (0.0-1.0) for GL_TEXTURE_2D
    glBegin(GL_QUADS);
    glTexCoord2f(texX, texY + texHeight); glVertex2f(x, y);
    glTexCoord2f(texX + texWidth, texY + texHeight); glVertex2f(x + width, y);
    glTexCoord2f(texX + texWidth, texY); glVertex2f(x + width, y + height);
    glTexCoord2f(texX, texY); glVertex2f(x, y + height);
    glEnd();
}

void OpenGLRenderer::calculateCropCoordinates(const VideoLayer* layer, float& texX, float& texY, 
                                             float& texWidth, float& texHeight) {
    if (!layer) {
        return;
    }

    const auto& props = layer->properties();
    const FrameInfo& frameInfo = layer->getFrameInfo();
    
    calculateCropCoordinatesFromProps(props, frameInfo, texX, texY, texWidth, texHeight);
}

void OpenGLRenderer::calculateCropCoordinatesFromProps(const LayerProperties& props, const FrameInfo& frameInfo,
                                                       float& texX, float& texY, float& texWidth, float& texHeight) {
    if (frameInfo.width == 0 || frameInfo.height == 0) {
        texX = 0.0f;
        texY = 0.0f;
        texWidth = 1.0f;
        texHeight = 1.0f;
        return;
    }

    // Panorama mode: crop to 50% width with pan offset
    if (props.panoramaMode) {
        float cropWidth = frameInfo.width / 2.0f;
        float maxOffset = frameInfo.width - cropWidth;
        
        // Clamp pan offset
        int panOffset = props.panOffset;
        if (panOffset < 0) panOffset = 0;
        if (panOffset > static_cast<int>(maxOffset)) panOffset = static_cast<int>(maxOffset);
        
        // Calculate texture coordinates
        texX = static_cast<float>(panOffset) / frameInfo.width;
        texY = 0.0f;
        texWidth = cropWidth / frameInfo.width;
        texHeight = 1.0f;
    }
    // General crop
    else if (props.crop.enabled) {
        // Calculate crop rectangle in texture coordinates (0.0 to 1.0)
        texX = static_cast<float>(props.crop.x) / frameInfo.width;
        texY = static_cast<float>(props.crop.y) / frameInfo.height;
        texWidth = static_cast<float>(props.crop.width) / frameInfo.width;
        texHeight = static_cast<float>(props.crop.height) / frameInfo.height;
        
        // Clamp to valid range
        if (texX < 0.0f) texX = 0.0f;
        if (texY < 0.0f) texY = 0.0f;
        if (texX + texWidth > 1.0f) texWidth = 1.0f - texX;
        if (texY + texHeight > 1.0f) texHeight = 1.0f - texY;
    }
    else {
        // No crop - use full texture
        texX = 0.0f;
        texY = 0.0f;
        texWidth = 1.0f;
        texHeight = 1.0f;
    }
}

void OpenGLRenderer::applyLayerTransform(const VideoLayer* layer) {
    if (!layer) return;
    
    // Default quad size for backward compatibility
    applyLayerTransform(layer, 1.0f, 1.0f);
}

void OpenGLRenderer::applyLayerTransform(const VideoLayer* layer, float quad_x, float quad_y) {
    if (!layer) return;
    applyLayerTransformFromProps(layer->properties(), quad_x, quad_y);
}

void OpenGLRenderer::applyLayerTransformFromProps(const LayerProperties& props, float quad_x, float quad_y) {
    // Apply position (x, y) - convert from pixel coordinates to normalized coordinates
    // Viewport is -1 to 1, so we need to scale by viewport size
    if (viewportWidth_ > 0 && viewportHeight_ > 0) {
        float normX = (2.0f * props.x) / viewportWidth_;
        float normY = (2.0f * props.y) / viewportHeight_;
        glTranslatef(normX, -normY, 0.0f);  // Negative Y because OpenGL Y is inverted
    }
    
    // Apply scale
    glScalef(props.scaleX, props.scaleY, 1.0f);
    
    // Apply rotation (around center)
    if (props.rotation != 0.0f) {
        glTranslatef(0.5f, 0.5f, 0.0f);
        glRotatef(props.rotation, 0.0f, 0.0f, 1.0f);
        glTranslatef(-0.5f, -0.5f, 0.0f);
    }
    
    // Apply corner deformation (warping) if enabled
    if (props.cornerDeform.enabled) {
        // Calculate source corners (base quad)
        Point src[4];
        src[0].x = -quad_x;
        src[0].y = -quad_y;
        src[1].x = quad_x;
        src[1].y = -quad_y;
        src[2].x = quad_x;
        src[2].y = quad_y;
        src[3].x = -quad_x;
        src[3].y = quad_y;
        
        // Calculate destination corners (with deformation offsets)
        Point dst[4];
        dst[0].x = src[0].x + props.cornerDeform.corners[0];
        dst[0].y = src[0].y + props.cornerDeform.corners[1];
        dst[1].x = src[1].x + props.cornerDeform.corners[2];
        dst[1].y = src[1].y + props.cornerDeform.corners[3];
        dst[2].x = src[2].x + props.cornerDeform.corners[4];
        dst[2].y = src[2].y + props.cornerDeform.corners[5];
        dst[3].x = src[3].x + props.cornerDeform.corners[6];
        dst[3].y = src[3].y + props.cornerDeform.corners[7];
        
        // Calculate homography matrix
        GLfloat homography[16];
        findHomography(src, dst, homography);
        
        // Apply homography matrix
        glMultMatrixf(homography);
    }
}

void OpenGLRenderer::applyBlendMode(const VideoLayer* layer) {
    if (!layer) return;
    applyBlendModeFromProps(layer->properties());
}

void OpenGLRenderer::applyBlendModeFromProps(const LayerProperties& props) {
    switch (props.blendMode) {
        case LayerProperties::NORMAL:
            glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
            break;
        case LayerProperties::MULTIPLY:
            glBlendFunc(GL_DST_COLOR, GL_ZERO);
            break;
        case LayerProperties::SCREEN:
            glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_COLOR);
            break;
        case LayerProperties::OVERLAY:
            // Simplified overlay blend
            glBlendFunc(GL_SRC_ALPHA, GL_ONE);
            break;
    }
}

bool OpenGLRenderer::renderLayer(const VideoLayer* layer) {
    if (!layer || !layer->isReady()) {
        return false;
    }

    // Get properties reference (safe since everything runs in main thread)
    const LayerProperties& props = layer->properties();
    if (!props.visible) {
        return false;
    }

            // Check if frame is on GPU (hardware-decoded)
            const FrameBuffer* cpuBuffer = nullptr;
            const GPUTextureFrameBuffer* gpuBuffer = nullptr;
            bool isOnGPU = layer->getPreparedFrame(cpuBuffer, gpuBuffer);
            
            
            if (isOnGPU && gpuBuffer && gpuBuffer->isValid()) {
                // Frame is on GPU - use GPU rendering path
                const FrameInfo& frameInfo = layer->getFrameInfo();
                return renderLayerFromGPU(*gpuBuffer, props, frameInfo);
            } else if (!isOnGPU && cpuBuffer && cpuBuffer->isValid()) {
                // Frame is on CPU - use cached texture per layer
                // IMPORTANT: Each layer needs its own texture when using CPU frames
                // We cache textures per layer to avoid expensive create/delete every frame
                
                const FrameInfo& info = cpuBuffer->info();
                int layerId = layer->getLayerId();
                int layerTextureWidth = info.width;
                int layerTextureHeight = info.height;
                
                // Check if we have a cached texture for this layer
                GLuint layerTextureId = 0;
                auto cacheIt = layerTextureCache_.find(layerId);
                
        // Calculate quad size with letterboxing (matches original xjadeo)
        // Original uses _gl_quad_x and _gl_quad_y for letterboxing
        float quad_x = 1.0f;
        float quad_y = 1.0f;
        
        // Get frame info for aspect ratio calculation
        const FrameInfo& frameInfo = layer->getFrameInfo();
        
        if (letterbox_) {
            // Calculate aspect ratios (matches original xjadeo logic)
            float asp_src = frameInfo.aspect > 0.0f ? frameInfo.aspect : (float)props.width / (float)props.height;
            float asp_dst = (float)viewportWidth_ / (float)viewportHeight_;
            
            if (asp_dst > asp_src) {
                // Destination is wider - letterbox left/right
                quad_x = asp_src / asp_dst;
                quad_y = 1.0f;
            } else {
                // Destination is taller - letterbox top/bottom
                quad_x = 1.0f;
                quad_y = asp_dst / asp_src;
            }
        }
        
        // Always use shader-based rendering for CPU frames when shaders available
        // This provides consistent behavior and supports color correction
        // The uniform branch (uColorCorrectionEnabled) has negligible overhead (~0.02%)
        // compared to the potential visual artifacts from switching render paths mid-playback
        if (useShaders_ && rgbaShader_) {
            // Shader-based rendering path for CPU frames
            // Uses GL_TEXTURE_2D for shader compatibility
            
            // Create/update a GL_TEXTURE_2D for shader-based rendering
            GLuint shaderTextureId = 0;
            auto cacheIt = layerTextureCache_.find(layerId);
            
            LayerTextureCache* cachePtr = nullptr;
            if (cacheIt != layerTextureCache_.end() &&
                cacheIt->second.width == layerTextureWidth &&
                cacheIt->second.height == layerTextureHeight) {
                shaderTextureId = cacheIt->second.textureId;
                cachePtr = &cacheIt->second;
            } else {
                // Create new GL_TEXTURE_2D
                if (cacheIt != layerTextureCache_.end()) {
                    texturesToDelete_.push_back(cacheIt->second.textureId);
                    cleanupLayerPBOs(cacheIt->second);
                    layerTextureCache_.erase(cacheIt);
                }
                
                glGenTextures(1, &shaderTextureId);
                glBindTexture(GL_TEXTURE_2D, shaderTextureId);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
                glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
                glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, layerTextureWidth, layerTextureHeight, 
                             0, GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
                
                LayerTextureCache cache;
                cache.textureId = shaderTextureId;
                cache.width = layerTextureWidth;
                cache.height = layerTextureHeight;
                cache.pbo[0] = 0;
                cache.pbo[1] = 0;
                cache.pboIndex = 0;
                cache.pboInitialized = false;
                layerTextureCache_[layerId] = cache;
                cachePtr = &layerTextureCache_[layerId];
            }
            
            // Upload frame data using PBO double-buffering for async transfer
            // This avoids blocking the render thread during CPU→GPU copy
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, shaderTextureId);
            
            size_t dataSize = static_cast<size_t>(layerTextureWidth) * layerTextureHeight * 4;
            
            if (cachePtr && initLayerPBOs(*cachePtr, layerTextureWidth, layerTextureHeight)) {
                // PBO path: async upload
                int currentPBO = cachePtr->pboIndex;
                int nextPBO = 1 - currentPBO;
                
                // Bind the "next" PBO for texture upload (data was copied last frame)
                // On first frame, this will upload uninitialized data, but that's ok
                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, cachePtr->pbo[nextPBO]);
                glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, layerTextureWidth, layerTextureHeight,
                                GL_BGRA, GL_UNSIGNED_BYTE, nullptr);  // offset 0 in PBO
                
                // Now copy new frame data to "current" PBO (async DMA)
                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, cachePtr->pbo[currentPBO]);
                // Use GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT for best performance
                void* ptr = glMapBufferRange(GL_PIXEL_UNPACK_BUFFER, 0, dataSize,
                                             GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT);
                if (ptr) {
                    memcpy(ptr, cpuBuffer->data(), dataSize);
                    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
                }
                glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
                
                // Swap PBO index for next frame
                cachePtr->pboIndex = nextPBO;
            } else {
                // Fallback: direct upload (no PBO)
            glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, layerTextureWidth, layerTextureHeight,
                            GL_BGRA, GL_UNSIGNED_BYTE, cpuBuffer->data());
            }
            
            // Apply blend mode
            applyBlendModeFromProps(props);
            
            // Use shader
            ShaderProgram* shader = (props.cornerDeform.enabled && 
                                     props.cornerDeform.highQuality && 
                                     rgbaShaderHQ_) 
                                   ? rgbaShaderHQ_.get() 
                                   : rgbaShader_.get();
            shader->use();
            shader->setUniform("uTexture", 0);
            shader->setUniform("uOpacity", props.opacity);
            
            // Set color correction uniforms (uses uniform branch for zero-cost when disabled)
            setColorCorrectionUniforms(shader, props.colorAdjust);
            
            // Handle corner deformation
            if (props.cornerDeform.enabled) {
                Point src[4], dst[4];
                src[0].x = -quad_x; src[0].y = -quad_y;
                src[1].x = quad_x;  src[1].y = -quad_y;
                src[2].x = quad_x;  src[2].y = quad_y;
                src[3].x = -quad_x; src[3].y = quad_y;
                
                for (int i = 0; i < 4; ++i) {
                    dst[i].x = src[i].x + props.cornerDeform.corners[i * 2];
                    dst[i].y = src[i].y + props.cornerDeform.corners[i * 2 + 1];
                }
                
                GLfloat homography[16];
                findHomography(src, dst, homography);
                shader->setUniform("uUseHomography", 1);
                shader->setUniformMatrix4fv("uHomography", homography);
            } else {
                shader->setUniform("uUseHomography", 0);
            }
            
            // Compute MVP matrix
            float mvp[16];
            computeMVPMatrix(mvp, 0.0f, 0.0f, quad_x, quad_y, props);
            shader->setUniformMatrix4fv("uMVP", mvp);
            
            // Draw using VAO
            glBindVertexArray(quadVAO_);
            glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
            glBindVertexArray(0);
            
            shader->unbind();
            glBindTexture(GL_TEXTURE_2D, 0);
            
            return true;
        }
        
        // Fixed-function fallback (only if shaders unavailable - legacy systems)
        // Use GL_TEXTURE_RECTANGLE_ARB for fixed-function path
        if (cacheIt != layerTextureCache_.end()) {
            // Texture exists - check if size matches
            if (cacheIt->second.width == layerTextureWidth && 
                cacheIt->second.height == layerTextureHeight) {
                // Reuse existing texture
                layerTextureId = cacheIt->second.textureId;
            } else {
                // Size changed - delete old texture and create new one
                texturesToDelete_.push_back(cacheIt->second.textureId);
                layerTextureCache_.erase(cacheIt);
                cacheIt = layerTextureCache_.end();
            }
        }
        
        // Create new texture if needed
        if (layerTextureId == 0) {
            glGenTextures(1, &layerTextureId);
            if (layerTextureId == 0) {
                return false;
            }
            
            glBindTexture(GL_TEXTURE_RECTANGLE_ARB, layerTextureId);
            glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            // Use GL_REPLACE instead of GL_DECAL for proper texture rendering
            // GL_DECAL blends with vertex color based on alpha, which can cause black output
            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
            
            // Allocate texture storage
            glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, 
                         layerTextureWidth, layerTextureHeight, 0,
                         GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
            
            // Cache the texture
            LayerTextureCache cache;
            cache.textureId = layerTextureId;
            cache.width = layerTextureWidth;
            cache.height = layerTextureHeight;
            layerTextureCache_[layerId] = cache;
        }
        
        // Upload frame data to cached texture
        // glEnable is deprecated in Core Profile - only use in compatibility mode
        if (!isCoreProfile_) {
        glEnable(GL_TEXTURE_RECTANGLE_ARB);
        }
        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, layerTextureId);
        glTexSubImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0,
                        layerTextureWidth, layerTextureHeight,
                        GL_BGRA, GL_UNSIGNED_BYTE, cpuBuffer->data());
        
        // Fixed-function fallback (only if shaders unavailable - legacy systems)
        // Save matrix state before applying transforms
        glPushMatrix();
        
        // Apply layer transform using the thread-safe props copy
        applyLayerTransformFromProps(props, quad_x, quad_y);

        // Apply blend mode using the thread-safe props copy
        applyBlendModeFromProps(props);

        // Set opacity
        glColor4f(1.0f, 1.0f, 1.0f, props.opacity);
        
        // Render centered quad (matches original xjadeo)
        float x = -quad_x;
        float y = -quad_y;
        float w = 2.0f * quad_x;
        float h = 2.0f * quad_y;

                // Calculate texture coordinates for cropping/panorama using thread-safe props copy
                float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
                calculateCropCoordinatesFromProps(props, frameInfo, texX, texY, texWidth, texHeight);

                // Regular texture uses GL_TEXTURE_RECTANGLE_ARB (already bound above)
                // Use pixel coordinates for GL_TEXTURE_RECTANGLE_ARB
                glBegin(GL_QUADS);
                glTexCoord2f(0.0f, (GLfloat)layerTextureHeight); glVertex2f(x, y);
                glTexCoord2f((GLfloat)layerTextureWidth, (GLfloat)layerTextureHeight); glVertex2f(x + w, y);
                glTexCoord2f((GLfloat)layerTextureWidth, 0.0f); glVertex2f(x + w, y + h);
                glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y + h);
                glEnd();
                
                // Unbind texture (texture is cached, don't delete)
                glBindTexture(GL_TEXTURE_RECTANGLE_ARB, 0);
                glDisable(GL_TEXTURE_RECTANGLE_ARB);

                glPopMatrix();

                return true;
    } else {
        // No valid frame available
        return false;
    }
}

void OpenGLRenderer::compositeLayers(const std::vector<const VideoLayer*>& layers) {
    // Check if master transforms are active
    bool useMasterFBO = masterProperties_.isActive();
    
    if (useMasterFBO) {
        // Initialize or resize FBO if needed
        if (!masterFBOInitialized_ || masterFBOWidth_ != viewportWidth_ || masterFBOHeight_ != viewportHeight_) {
            if (!initMasterFBO(viewportWidth_, viewportHeight_)) {
                LOG_ERROR << "Failed to initialize master FBO, falling back to direct rendering";
                useMasterFBO = false;
            }
        }
    }
    
    if (useMasterFBO && masterFBOInitialized_) {
        // Render layers to FBO
        glBindFramebuffer(GL_FRAMEBUFFER, masterFBO_);
        glViewport(0, 0, masterFBOWidth_, masterFBOHeight_);
    }
    
    // Clear to opaque black (alpha = 1.0)
    glClear(GL_COLOR_BUFFER_BIT);

    // Render layers in z-order (already sorted by LayerManager)
    for (const VideoLayer* layer : layers) {
        if (layer && layer->isReady()) {
            renderLayer(layer);
            // If no frame was rendered, clear will show black screen (expected)
            // This is normal when waiting for MTC or when no frames are available yet
        }
    }
    
    if (useMasterFBO && masterFBOInitialized_) {
        // Unbind FBO, render to screen with master transforms
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        glViewport(0, 0, viewportWidth_, viewportHeight_);
        
        // Clear screen
        glClear(GL_COLOR_BUFFER_BIT);
        
        // Render FBO texture with master transforms
        renderMasterQuadWithTransforms();
    }
}

void OpenGLRenderer::updateTexture(int width, int height) {
    textureWidth_ = width;
    textureHeight_ = height;
    
    if (textureId_ != 0) {
        glBindTexture(GL_TEXTURE_RECTANGLE_ARB, textureId_);
        glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, 
                     width, height, 0,
                     GL_BGRA, GL_UNSIGNED_BYTE, nullptr);
    }
}

void OpenGLRenderer::cleanupDeferredTextures() {
    // Delete textures that were deferred from previous frame
    // This is called AFTER swapBuffers() to ensure OpenGL is done using them
    if (!texturesToDelete_.empty()) {
        glDeleteTextures(static_cast<GLsizei>(texturesToDelete_.size()), texturesToDelete_.data());
        texturesToDelete_.clear();
    }
}

bool OpenGLRenderer::renderLayerFromGPU(const GPUTextureFrameBuffer& gpuFrame, const LayerProperties& properties, const FrameInfo& frameInfo) {
    if (!gpuFrame.isValid()) {
        LOG_VERBOSE << "renderLayerFromGPU: gpuFrame is invalid";
        return false;
    }

    if (!properties.visible) {
        return false;
    }

    TexturePlaneType planeType = gpuFrame.getPlaneType();

    // For multi-plane formats (NV12, YUV420P), skip bindGPUTexture
    // We'll bind textures manually in the shader path
    if (planeType == TexturePlaneType::SINGLE) {
        // Single-plane (HAP, RGBA) - use bindGPUTexture
        if (!bindGPUTexture(gpuFrame)) {
            LOG_WARNING << "renderLayerFromGPU: bindGPUTexture failed";
            return false;
        }
    }

    // Calculate quad size with letterboxing first (needed for corner deformation)
    float quad_x = 1.0f;
    float quad_y = 1.0f;
    
    if (letterbox_) {
        float asp_src = frameInfo.aspect > 0.0f ? frameInfo.aspect : (float)properties.width / (float)properties.height;
        float asp_dst = (float)viewportWidth_ / (float)viewportHeight_;
        
        if (asp_dst > asp_src) {
            quad_x = asp_src / asp_dst;
            quad_y = 1.0f;
        } else {
            quad_x = 1.0f;
            quad_y = asp_dst / asp_src;
        }
    }
    
    // Use shader-based rendering if available (supports corner deformation)
    if (useShaders_ && rgbaShader_) {
        // Apply blend mode (use shared function to avoid duplication)
        applyBlendModeFromProps(properties);
        
        // Select shader based on texture format and quality setting
        ShaderProgram* shader = nullptr;
        
        if (planeType == TexturePlaneType::YUV_NV12 && nv12Shader_) {
            // NV12 format (VAAPI, CUDA)
            shader = nv12Shader_.get();
            
            GLuint texY = gpuFrame.getTextureId(0);
            GLuint texUV = gpuFrame.getTextureId(1);
            
            // Bind Y plane to texture unit 0
            // Note: glEnable(GL_TEXTURE_2D) not needed with shaders (mpv doesn't use it)
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, texY);
            
            // Bind UV plane to texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, texUV);
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexY", 0);   // Texture unit 0
            shader->setUniform("uTexUV", 1);  // Texture unit 1
            
            
        } else if (planeType == TexturePlaneType::YUV_420P && yuv420pShader_) {
            // YUV420P format (software decoded, some hardware decoders)
            shader = yuv420pShader_.get();
            
            // Bind Y plane to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(0));
            
            // Bind U plane to texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(1));
            
            // Bind V plane to texture unit 2
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(2));
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexY", 0);   // Texture unit 0
            shader->setUniform("uTexU", 1);   // Texture unit 1
            shader->setUniform("uTexV", 2);   // Texture unit 2
            
        } else if (planeType == TexturePlaneType::HAP_Q_ALPHA && hapQAlphaShader_) {
            // HAP Q Alpha (dual texture: YCoCg color + alpha)
            shader = hapQAlphaShader_.get();
            
            // Bind YCoCg color texture to unit 0
            // Note: glEnable(GL_TEXTURE_2D) not needed with shaders (mpv doesn't use it)
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(0));
            
            // Bind alpha texture to unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, gpuFrame.getTextureId(1));
            
            // Reset to texture unit 0
            glActiveTexture(GL_TEXTURE0);
            
            shader->use();
            shader->setUniform("uTexture", 0);       // YCoCg texture unit 0
            shader->setUniform("uTextureAlpha", 1);  // Alpha texture unit 1
            
        } else {
            // RGBA/single-plane format (HAP, HAP Alpha, decompressed frames)
            // Check if this is HAP Q (YCoCg format)
            bool isHAP = gpuFrame.isHAPTexture();
            HapVariant variant = gpuFrame.getHapVariant();
            
            if (isHAP && variant == HapVariant::HAP_Q && hapQShader_) {
                // HAP Q: YCoCg DXT5 (single texture) - needs YCoCg→RGB conversion
                shader = hapQShader_.get();
                shader->use();
                shader->setUniform("uTexture", 0);  // Texture unit 0
            } else {
                // Standard RGBA/HAP/HAP Alpha/HAP R (BPTC RGBA renders like standard RGBA)
                // NOTE: HAP R support is UNTESTED - needs verification with actual HAP R files
                shader = (properties.cornerDeform.enabled && 
                         properties.cornerDeform.highQuality && 
                         rgbaShaderHQ_) 
                        ? rgbaShaderHQ_.get() 
                        : rgbaShader_.get();
                
                shader->use();
                shader->setUniform("uTexture", 0);  // Texture unit 0
            }
        }
        
        shader->setUniform("uOpacity", properties.opacity);
        
        // Set color correction uniforms for per-layer color adjustment
        setColorCorrectionUniforms(shader, properties.colorAdjust);
        
        // Handle corner deformation (homography warping) - works with all shader types
        if (properties.cornerDeform.enabled) {
            // Calculate source corners (base quad before warping)
            Point src[4];
            src[0].x = -quad_x;
            src[0].y = -quad_y;
            src[1].x = quad_x;
            src[1].y = -quad_y;
            src[2].x = quad_x;
            src[2].y = quad_y;
            src[3].x = -quad_x;
            src[3].y = quad_y;
            
            // Calculate destination corners (with deformation offsets)
            Point dst[4];
            dst[0].x = src[0].x + properties.cornerDeform.corners[0];
            dst[0].y = src[0].y + properties.cornerDeform.corners[1];
            dst[1].x = src[1].x + properties.cornerDeform.corners[2];
            dst[1].y = src[1].y + properties.cornerDeform.corners[3];
            dst[2].x = src[2].x + properties.cornerDeform.corners[4];
            dst[2].y = src[2].y + properties.cornerDeform.corners[5];
            dst[3].x = src[3].x + properties.cornerDeform.corners[6];
            dst[3].y = src[3].y + properties.cornerDeform.corners[7];
            
            // Compute homography matrix
            GLfloat homography[16];
            findHomography(src, dst, homography);
            
            shader->setUniform("uUseHomography", 1);
            shader->setUniformMatrix4fv("uHomography", homography);
            
            // Set anisotropy level for high-quality RGBA shader
            if (properties.cornerDeform.highQuality && 
                planeType == TexturePlaneType::SINGLE && 
                rgbaShaderHQ_ && shader == rgbaShaderHQ_.get()) {
                shader->setUniform("uAnisotropy", 4.0f);
            }
        } else {
            shader->setUniform("uUseHomography", 0);
        }
        
        // Compute MVP matrix (position, scale, rotation - homography applied separately in shader)
        float mvp[16];
        computeMVPMatrix(mvp, 0.0f, 0.0f, quad_x, quad_y, properties);
        shader->setUniformMatrix4fv("uMVP", mvp);
        
        // Calculate texture coordinates for cropping/panorama
        float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
        calculateCropCoordinatesFromProps(properties, frameInfo, texX, texY, texWidth, texHeight);
        
        // TODO: Implement texture coordinate transformation for crop/panorama in shader
        // For now, we'll render without crop (will be implemented in Phase 2)
        
        // Bind VAO and draw
        glBindVertexArray(quadVAO_);
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
        glBindVertexArray(0);
        
        // NOTE: Removed glFinish() here - it was causing GPU pipeline stalls
        // The DMA-BUF data is read by the GPU during glDrawArrays, and we keep
        // the EGL images/DMA-BUFs alive until the next frame anyway.
        // The page flip (vsync wait) provides the necessary synchronization.
        // This matches mpv's approach for smooth playback.
        
        shader->unbind();
        
        // Unbind and disable multi-plane textures (like mpv does)
        if (planeType == TexturePlaneType::YUV_NV12 || planeType == TexturePlaneType::YUV_420P) {
            // Unbind texture unit 1
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, 0);
            glDisable(GL_TEXTURE_2D);
            
            // Unbind texture unit 0
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, 0);
            glDisable(GL_TEXTURE_2D);
            
            if (planeType == TexturePlaneType::YUV_420P) {
                // Also unbind texture unit 2 for YUV420P
                glActiveTexture(GL_TEXTURE2);
                glBindTexture(GL_TEXTURE_2D, 0);
                glDisable(GL_TEXTURE_2D);
                glActiveTexture(GL_TEXTURE0);
            }
        }
        
        return true;
    }

    // Fallback: Fixed-function pipeline (only if shaders unavailable)
    // Apply layer transform
    glPushMatrix();
    
    // Apply position (x, y) - convert from pixel coordinates to normalized coordinates
    if (viewportWidth_ > 0 && viewportHeight_ > 0) {
        float normX = (2.0f * properties.x) / viewportWidth_;
        float normY = (2.0f * properties.y) / viewportHeight_;
        glTranslatef(normX, -normY, 0.0f);  // Negative Y because OpenGL Y is inverted
    }
    
    glScalef(properties.scaleX, properties.scaleY, 1.0f);
    
    // Apply rotation (around center)
    if (properties.rotation != 0.0f) {
        glTranslatef(0.5f, 0.5f, 0.0f);
        glRotatef(properties.rotation, 0.0f, 0.0f, 1.0f);
        glTranslatef(-0.5f, -0.5f, 0.0f);
    }
    
    // Apply corner deformation (warping) if enabled
    if (properties.cornerDeform.enabled) {
        // Calculate source corners (base quad)
        Point src[4];
        src[0].x = -quad_x;
        src[0].y = -quad_y;
        src[1].x = quad_x;
        src[1].y = -quad_y;
        src[2].x = quad_x;
        src[2].y = quad_y;
        src[3].x = -quad_x;
        src[3].y = quad_y;
        
        // Calculate destination corners (with deformation offsets)
        Point dst[4];
        dst[0].x = src[0].x + properties.cornerDeform.corners[0];
        dst[0].y = src[0].y + properties.cornerDeform.corners[1];
        dst[1].x = src[1].x + properties.cornerDeform.corners[2];
        dst[1].y = src[1].y + properties.cornerDeform.corners[3];
        dst[2].x = src[2].x + properties.cornerDeform.corners[4];
        dst[2].y = src[2].y + properties.cornerDeform.corners[5];
        dst[3].x = src[3].x + properties.cornerDeform.corners[6];
        dst[3].y = src[3].y + properties.cornerDeform.corners[7];
        
        // Calculate homography matrix
        GLfloat homography[16];
        findHomography(src, dst, homography);
        
        // Apply homography matrix
        glMultMatrixf(homography);
    }

    // Apply blend mode (use shared function to avoid duplication)
    applyBlendModeFromProps(properties);

    // Set opacity
    glColor4f(1.0f, 1.0f, 1.0f, properties.opacity);
    
    // Render centered quad
    float x = -quad_x;
    float y = -quad_y;
    float w = 2.0f * quad_x;
    float h = 2.0f * quad_y;

    // Calculate texture coordinates for cropping/panorama
    float texX = 0.0f, texY = 0.0f, texWidth = 1.0f, texHeight = 1.0f;
    calculateCropCoordinatesFromProps(properties, frameInfo, texX, texY, texWidth, texHeight);

    // Render quad with texture coordinates
    // All GPU textures (HAP and hardware-decoded) use GL_TEXTURE_2D
    // GL_TEXTURE_2D uses normalized texture coordinates (0.0-1.0)
    GLenum target = GL_TEXTURE_2D;
    
    // Use normalized texture coordinates (0.0-1.0) for GL_TEXTURE_2D
    glBegin(GL_QUADS);
    glTexCoord2f(texX, texY + texHeight); glVertex2f(x, y);
    glTexCoord2f(texX + texWidth, texY + texHeight); glVertex2f(x + w, y);
    glTexCoord2f(texX + texWidth, texY); glVertex2f(x + w, y + h);
    glTexCoord2f(texX, texY); glVertex2f(x, y + h);
    glEnd();

    // Disable texture
    glDisable(target);
    glPopMatrix();

    return true;
}

void OpenGLRenderer::renderOSDItems(const std::vector<OSDRenderItem>& items) {
    if (items.empty()) {
        return;
    }

    // Save current OpenGL state before modifying for OSD rendering
    glPushAttrib(GL_ENABLE_BIT | GL_COLOR_BUFFER_BIT | GL_TEXTURE_BIT);
    
    // CRITICAL: Disable GL_TEXTURE_RECTANGLE_ARB (used by video layers) before rendering OSD
    // OSD uses GL_TEXTURE_2D, and both cannot be active simultaneously
    glDisable(GL_TEXTURE_RECTANGLE_ARB);
    
    // Save and set projection matrix for OSD (2D overlay in normalized coordinates)
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadIdentity();
    glOrtho(-1.0f, 1.0f, -1.0f, 1.0f, -1.0f, 1.0f);

    // Save and set modelview matrix for OSD
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glLoadIdentity();

    // Disable depth test (we're rendering 2D overlay on top of everything)
    glDisable(GL_DEPTH_TEST);
    // Ensure OSD is rendered on top by using a high depth value if depth test were enabled
    // Since depth test is disabled, this is just for clarity

    // Enable blending for OSD
    glEnable(GL_BLEND);
    // Use standard alpha blending for correct rendering of textures with alpha
    // GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA works for non-premultiplied alpha
    // This ensures transparent pixels (A=0) are completely invisible
    // When A=0: src contribution = 0, dst contribution = 1.0 * dst (unchanged)
    // When A=255: src contribution = 1.0 * src, dst contribution = 0 (fully opaque)
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    // Disable face culling
    glDisable(GL_CULL_FACE);
    
    // Enable texture 2D (OSD uses GL_TEXTURE_2D, not GL_TEXTURE_RECTANGLE_ARB)
    // Note: glEnable(GL_TEXTURE_2D) is deprecated in Core Profile
    if (!isCoreProfile_) {
    glEnable(GL_TEXTURE_2D);
    }
    
    // Set color to white (texture provides color)
    glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

    // Render each OSD item
    for (const auto& item : items) {
        if (item.textureId == 0) {
            LOG_WARNING << "OSD: Skipping item with textureId=0";
            continue;
        }

        glBindTexture(GL_TEXTURE_2D, item.textureId);
        
        // Set texture environment to MODULATE for proper alpha blending
        // Video layers use GL_DECAL which ignores alpha - we need MODULATE for transparency
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        // Calculate normalized coordinates
        // OpenGL coordinates: -1 to 1, with origin at center, Y up (top=1.0, bottom=-1.0)
        // Screen coordinates: 0 to viewportWidth/Height, with origin at top-left, Y down (top=0, bottom=height)
        // item.x and item.y are in screen pixels from top-left (item.y is top of text)
        float x = -1.0f + (2.0f * item.x / viewportWidth_);
        // Convert screen Y (top=0) to OpenGL Y (top=1.0): y_gl = 1.0 - 2.0 * (y_screen / height)
        float y = 1.0f - (2.0f * item.y / viewportHeight_);
        float w = 2.0f * item.width / viewportWidth_;
        // Height is negative because we're going down from top
        float h = -2.0f * item.height / viewportHeight_;

        // Ensure texture is bound and enabled
        if (!isCoreProfile_) {
        glEnable(GL_TEXTURE_2D);
        }
        
        // Set color to white with full opacity for text
        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);

        // Render textured quad with proper texture coordinates
        // OpenGL texture coordinates: (0,0) = bottom-left, (1,1) = top-right
        // Our bitmap is stored with (0,0) at top-left, so we need to flip Y
        // Top-left vertex -> (0,0) texture (bitmap top-left), bottom-left -> (0,1) texture (bitmap bottom-left)
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f); glVertex2f(x, y);           // Top-left vertex -> bitmap top-left (0,0)
        glTexCoord2f(1.0f, 0.0f); glVertex2f(x + w, y);       // Top-right vertex -> bitmap top-right (1,0)
        glTexCoord2f(1.0f, 1.0f); glVertex2f(x + w, y + h);   // Bottom-right vertex -> bitmap bottom-right (1,1)
        glTexCoord2f(0.0f, 1.0f); glVertex2f(x, y + h);       // Bottom-left vertex -> bitmap bottom-left (0,1)
        glEnd();
    }

    glBindTexture(GL_TEXTURE_2D, 0);
    glDisable(GL_TEXTURE_2D);
    
    // Restore matrices (must restore in reverse order)
    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glMatrixMode(GL_MODELVIEW);
    
    // Restore all OpenGL state (including GL_TEXTURE_RECTANGLE_ARB if it was enabled)
    glPopAttrib();
    
    // Re-enable GL_TEXTURE_RECTANGLE_ARB for video layers (they need it for next frame)
    if (!isCoreProfile_) {
    glEnable(GL_TEXTURE_RECTANGLE_ARB);
    }
}

bool OpenGLRenderer::initQuadVBO() {
    // Create a unit quad for rendering
    // Positions: [-1, -1] to [1, 1] (will be transformed by MVP matrix)
    // TexCoords: [0, 0] to [1, 1] (normalized texture coordinates)
    struct Vertex {
        float x, y;        // Position
        float u, v;        // Texture coordinate
    };
    
    // Quad vertices (two triangles forming a quad)
    // Order: bottom-left, bottom-right, top-right, top-left
    Vertex vertices[] = {
        {-1.0f, -1.0f,  0.0f, 1.0f},  // Bottom-left
        { 1.0f, -1.0f,  1.0f, 1.0f},  // Bottom-right
        { 1.0f,  1.0f,  1.0f, 0.0f},  // Top-right
        {-1.0f,  1.0f,  0.0f, 0.0f}   // Top-left
    };
    
    // Generate VAO and VBO
    glGenVertexArrays(1, &quadVAO_);
    glGenBuffers(1, &quadVBO_);
    
    if (quadVAO_ == 0 || quadVBO_ == 0) {
        LOG_ERROR << "Failed to generate VAO/VBO";
        cleanupQuadVBO();
        return false;
    }
    
    // Bind VAO
    glBindVertexArray(quadVAO_);
    
    // Bind and fill VBO
    glBindBuffer(GL_ARRAY_BUFFER, quadVBO_);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    // Set up vertex attributes
    // Position attribute (location = 0)
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
    
    // TexCoord attribute (location = 1)
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)(2 * sizeof(float)));
    
    // Unbind
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
    
    LOG_VERBOSE << "Quad VBO/VAO initialized (VAO: " << quadVAO_ << ", VBO: " << quadVBO_ << ")";
    return true;
}

void OpenGLRenderer::cleanupQuadVBO() {
    if (quadVBO_ != 0) {
        glDeleteBuffers(1, &quadVBO_);
        quadVBO_ = 0;
    }
    if (quadVAO_ != 0) {
        glDeleteVertexArrays(1, &quadVAO_);
        quadVAO_ = 0;
    }
}

bool OpenGLRenderer::initShaders() {
    // Create RGBA shader (for CPU frames, HAP)
    rgbaShader_ = std::make_unique<ShaderProgram>();
    if (!rgbaShader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_RGBA)) {
        LOG_ERROR << "Failed to create RGBA shader";
        cleanupShaders();
        return false;
    }
    
    // Create high-quality RGBA shader (for extreme corner warping)
    rgbaShaderHQ_ = std::make_unique<ShaderProgram>();
    if (!rgbaShaderHQ_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_RGBA_HQ)) {
        LOG_WARNING << "Failed to create HQ RGBA shader, will use standard quality for warping";
        rgbaShaderHQ_.reset();
    }
    
    // Create NV12 shader (for VAAPI/CUDA)
    nv12Shader_ = std::make_unique<ShaderProgram>();
    if (!nv12Shader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_NV12)) {
        LOG_ERROR << "Failed to create NV12 shader";
        cleanupShaders();
        return false;
    }
    
    // Create YUV420P shader (fallback)
    yuv420pShader_ = std::make_unique<ShaderProgram>();
    if (!yuv420pShader_->createFromSource(VideoShaders::VERTEX_SHADER, VideoShaders::FRAGMENT_YUV420P)) {
        LOG_ERROR << "Failed to create YUV420P shader";
        cleanupShaders();
        return false;
    }
    
    // Create HAP Q shader (YCoCg→RGB conversion)
    hapQShader_ = std::make_unique<ShaderProgram>();
    if (!hapQShader_->createFromSource(HAP_VERTEX_SHADER, HAP_Q_FRAGMENT_SHADER)) {
        LOG_WARNING << "Failed to create HAP Q shader, HAP Q videos will use fallback";
        hapQShader_.reset();
    }
    
    // Create HAP Q Alpha shader (dual texture: YCoCg + alpha)
    hapQAlphaShader_ = std::make_unique<ShaderProgram>();
    if (!hapQAlphaShader_->createFromSource(HAP_VERTEX_SHADER, HAP_Q_ALPHA_FRAGMENT_SHADER)) {
        LOG_WARNING << "Failed to create HAP Q Alpha shader, HAP Q Alpha videos will use fallback";
        hapQAlphaShader_.reset();
    }
    
    // Create master post-processing shader (for FBO with color correction)
    masterShader_ = std::make_unique<ShaderProgram>();
    if (!masterShader_->createFromSource(VideoShaders::MASTER_VERTEX_SHADER, VideoShaders::MASTER_FRAGMENT_SHADER)) {
        LOG_WARNING << "Failed to create master shader, master color correction will be disabled";
        masterShader_.reset();
    }
    
    LOG_VERBOSE << "All video shaders compiled successfully";
    return true;
}

void OpenGLRenderer::cleanupShaders() {
    rgbaShader_.reset();
    rgbaShaderHQ_.reset();
    nv12Shader_.reset();
    yuv420pShader_.reset();
    hapQShader_.reset();
    hapQAlphaShader_.reset();
    masterShader_.reset();
}

void OpenGLRenderer::computeMVPMatrix(float* mvp, float x, float y, float width, float height,
                                     const LayerProperties& props) {
    // Initialize as identity matrix
    for (int i = 0; i < 16; i++) {
        mvp[i] = 0.0f;
    }
    mvp[0] = mvp[5] = mvp[10] = mvp[15] = 1.0f;
    
    // Apply position and scale (model matrix)
    // Normalized device coordinates: x, y in [-1, 1]
    float scaleX = width * props.scaleX;
    float scaleY = height * props.scaleY;
    
    // Position: center the quad at (x, y)
    float posX = x;
    float posY = y;
    
    // Build MVP as: Translation * Rotation * Scale
    // For simplicity, we'll build a combined matrix
    
    // Scale
    mvp[0] = scaleX;   // Scale X
    mvp[5] = scaleY;   // Scale Y
    
    // Rotation (around Z axis)
    if (props.rotation != 0.0f) {
        float rad = props.rotation * M_PI / 180.0f;
        float cosR = std::cos(rad);
        float sinR = std::sin(rad);
        
        // Combine scale and rotation
        float m00 = scaleX * cosR;
        float m01 = scaleX * (-sinR);
        float m10 = scaleY * sinR;
        float m11 = scaleY * cosR;
        
        mvp[0] = m00;
        mvp[1] = m10;
        mvp[4] = m01;
        mvp[5] = m11;
    }
    
    // Translation
    mvp[12] = posX;
    mvp[13] = posY;
}

void OpenGLRenderer::renderQuadWithShader(ShaderProgram* shader, float x, float y, 
                                         float width, float height, const LayerProperties& props) {
    if (!shader || !shader->isValid()) {
        return;
    }
    
    // Use shader
    shader->use();
    
    // Compute MVP matrix
    float mvp[16];
    computeMVPMatrix(mvp, x, y, width, height, props);
    
    // Set uniforms
    shader->setUniformMatrix4fv("uMVP", mvp);
    shader->setUniform("uOpacity", props.opacity);
    
    // Set color correction uniforms
    setColorCorrectionUniforms(shader, props.colorAdjust);
    
    // Bind VAO and draw
    glBindVertexArray(quadVAO_);
    glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
    glBindVertexArray(0);
    
    // Unbind shader
    shader->unbind();
}

bool OpenGLRenderer::initMasterFBO(int width, int height) {
    // Clean up existing FBO if size changed
    if (masterFBOInitialized_ && (masterFBOWidth_ != width || masterFBOHeight_ != height)) {
        cleanupMasterFBO();
    }
    
    if (masterFBOInitialized_) {
        return true;  // Already initialized with correct size
    }
    
    LOG_INFO << "Initializing master FBO: " << width << "x" << height;
    
    // Generate FBO
    glGenFramebuffers(1, &masterFBO_);
    if (masterFBO_ == 0) {
        LOG_ERROR << "Failed to generate master FBO";
        return false;
    }
    
    // Generate texture for FBO
    glGenTextures(1, &masterFBOTexture_);
    if (masterFBOTexture_ == 0) {
        glDeleteFramebuffers(1, &masterFBO_);
        masterFBO_ = 0;
        LOG_ERROR << "Failed to generate master FBO texture";
        return false;
    }
    
    // Setup texture
    glBindTexture(GL_TEXTURE_2D, masterFBOTexture_);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    
    // Attach texture to FBO
    glBindFramebuffer(GL_FRAMEBUFFER, masterFBO_);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, masterFBOTexture_, 0);
    
    // Check FBO completeness
    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE) {
        LOG_ERROR << "Master FBO is not complete: 0x" << std::hex << status;
        glBindFramebuffer(GL_FRAMEBUFFER, 0);
        cleanupMasterFBO();
        return false;
    }
    
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    glBindTexture(GL_TEXTURE_2D, 0);
    
    masterFBOWidth_ = width;
    masterFBOHeight_ = height;
    masterFBOInitialized_ = true;
    
    LOG_INFO << "Master FBO initialized successfully";
    return true;
}

void OpenGLRenderer::cleanupMasterFBO() {
    if (masterFBOTexture_ != 0) {
        glDeleteTextures(1, &masterFBOTexture_);
        masterFBOTexture_ = 0;
    }
    if (masterFBO_ != 0) {
        glDeleteFramebuffers(1, &masterFBO_);
        masterFBO_ = 0;
    }
    masterFBOWidth_ = 0;
    masterFBOHeight_ = 0;
    masterFBOInitialized_ = false;
}

void OpenGLRenderer::renderMasterQuadWithTransforms() {
    // Render the FBO texture to screen with master transforms applied
    const MasterProperties& props = masterProperties_;
    
    // PERFORMANCE: True zero-cost optimization for master layer
    // ----------------------------------------------------------
    // When color correction is disabled, we use the fixed-function path
    // which has ZERO shader overhead. This is the "separate shader" approach
    // applied to the master layer. For per-layer rendering, we use uniform
    // branching instead (see setColorCorrectionUniforms for analysis).
    //
    // Use shader path if color correction is active and shader is available
    if (props.colorAdjust.isActive() && masterShader_ && masterShader_->isValid()) {
        // Shader-based rendering with color correction
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, masterFBOTexture_);
        
        masterShader_->use();
        masterShader_->setUniform("uTexture", 0);
        masterShader_->setUniform("uOpacity", props.opacity);
        setMasterColorCorrectionUniforms(masterShader_.get(), props.colorAdjust);
        
        // Enable blending
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        // Save matrix state for transforms
        glPushMatrix();
        
        // Apply position offset
        glTranslatef(props.x, props.y, 0.0f);
        
        // Apply scale
        glScalef(props.scaleX, props.scaleY, 1.0f);
        
        // Apply rotation
        if (props.rotation != 0.0f) {
            glRotatef(props.rotation, 0.0f, 0.0f, 1.0f);
        }
        
        // Apply corner deformation
        if (props.cornerDeform.enabled) {
            Point src[4];
            src[0].x = -1.0; src[0].y = -1.0;
            src[1].x =  1.0; src[1].y = -1.0;
            src[2].x =  1.0; src[2].y =  1.0;
            src[3].x = -1.0; src[3].y =  1.0;
            
            Point dst[4];
            dst[0].x = src[0].x + props.cornerDeform.corners[0];
            dst[0].y = src[0].y + props.cornerDeform.corners[1];
            dst[1].x = src[1].x + props.cornerDeform.corners[2];
            dst[1].y = src[1].y + props.cornerDeform.corners[3];
            dst[2].x = src[2].x + props.cornerDeform.corners[4];
            dst[2].y = src[2].y + props.cornerDeform.corners[5];
            dst[3].x = src[3].x + props.cornerDeform.corners[6];
            dst[3].y = src[3].y + props.cornerDeform.corners[7];
            
            GLfloat homography[16];
            findHomography(src, dst, homography);
            glMultMatrixf(homography);
        }
        
        // Draw fullscreen quad using VAO
        glBindVertexArray(quadVAO_);
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
        glBindVertexArray(0);
        
        glPopMatrix();
        masterShader_->unbind();
        
        glBindTexture(GL_TEXTURE_2D, 0);
        glDisable(GL_BLEND);
    } else {
        // Fixed-function fallback (no color correction)
        // Note: This path won't work in Core Profile (DRM mode)
        if (!isCoreProfile_) {
        glEnable(GL_TEXTURE_2D);
        }
        glBindTexture(GL_TEXTURE_2D, masterFBOTexture_);
        
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
        
        glPushMatrix();
        
        // Apply position offset
        glTranslatef(props.x, props.y, 0.0f);
        
        // Apply scale
        glScalef(props.scaleX, props.scaleY, 1.0f);
        
        // Apply rotation (around center)
        if (props.rotation != 0.0f) {
            glRotatef(props.rotation, 0.0f, 0.0f, 1.0f);
        }
        
        // Apply corner deformation if enabled
        if (props.cornerDeform.enabled) {
            Point src[4];
            src[0].x = -1.0; src[0].y = -1.0;
            src[1].x =  1.0; src[1].y = -1.0;
            src[2].x =  1.0; src[2].y =  1.0;
            src[3].x = -1.0; src[3].y =  1.0;
            
            Point dst[4];
            dst[0].x = src[0].x + props.cornerDeform.corners[0];
            dst[0].y = src[0].y + props.cornerDeform.corners[1];
            dst[1].x = src[1].x + props.cornerDeform.corners[2];
            dst[1].y = src[1].y + props.cornerDeform.corners[3];
            dst[2].x = src[2].x + props.cornerDeform.corners[4];
            dst[2].y = src[2].y + props.cornerDeform.corners[5];
            dst[3].x = src[3].x + props.cornerDeform.corners[6];
            dst[3].y = src[3].y + props.cornerDeform.corners[7];
            
            GLfloat homography[16];
            findHomography(src, dst, homography);
            glMultMatrixf(homography);
        }
        
        // Set opacity
        glColor4f(1.0f, 1.0f, 1.0f, props.opacity);
        
        // Enable blending for opacity
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        
        // Render quad with FBO texture
        glBegin(GL_QUADS);
        glTexCoord2f(0.0f, 0.0f); glVertex2f(-1.0f, -1.0f);
        glTexCoord2f(1.0f, 0.0f); glVertex2f( 1.0f, -1.0f);
        glTexCoord2f(1.0f, 1.0f); glVertex2f( 1.0f,  1.0f);
        glTexCoord2f(0.0f, 1.0f); glVertex2f(-1.0f,  1.0f);
        glEnd();
        
        glPopMatrix();
        
        glBindTexture(GL_TEXTURE_2D, 0);
        glDisable(GL_TEXTURE_2D);
        glDisable(GL_BLEND);
        glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
    }
}

// Set color correction uniforms for per-layer rendering
//
// DESIGN DECISION: Always use shader path, rely on uniform branching
// -------------------------------------------------------------------
// We always use the shader path for all layers (CPU and GPU frames) rather than
// switching between fixed-function and shader paths based on color correction state.
//
// Why:
// 1. Consistent rendering - no visual artifacts from path switching mid-playback
// 2. Negligible overhead - uniform branch check costs ~0.02% GPU per layer
// 3. Simpler code - single render path to maintain
//
// When color correction is disabled (isActive() == false):
//   - Only 1 uniform is set (uColorCorrectionEnabled = 0)
//   - Shader branch skips all color math (~0.02% GPU overhead)
//
// When enabled:
//   - 6 uniforms are set (enabled + 5 color values)
//   - Full color correction applied in shader
//
void OpenGLRenderer::setColorCorrectionUniforms(ShaderProgram* shader, 
                                                const LayerProperties::ColorAdjustment& colorAdjust) {
    if (!shader) return;
    
    bool enabled = colorAdjust.isActive();
    shader->setUniform("uColorCorrectionEnabled", enabled ? 1 : 0);
    
    if (enabled) {
        shader->setUniform("uBrightness", colorAdjust.brightness);
        shader->setUniform("uContrast", colorAdjust.contrast);
        shader->setUniform("uSaturation", colorAdjust.saturation);
        shader->setUniform("uHue", colorAdjust.hue);
        shader->setUniform("uGamma", colorAdjust.gamma);
    }
}

void OpenGLRenderer::setMasterColorCorrectionUniforms(ShaderProgram* shader,
                                                      const MasterProperties::ColorAdjustment& colorAdjust) {
    if (!shader) return;
    
    bool enabled = colorAdjust.isActive();
    shader->setUniform("uColorCorrectionEnabled", enabled ? 1 : 0);
    
    if (enabled) {
        shader->setUniform("uBrightness", colorAdjust.brightness);
        shader->setUniform("uContrast", colorAdjust.contrast);
        shader->setUniform("uSaturation", colorAdjust.saturation);
        shader->setUniform("uHue", colorAdjust.hue);
        shader->setUniform("uGamma", colorAdjust.gamma);
    }
}

} // namespace videocomposer

